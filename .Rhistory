test = c(1, 2, 3, 4)
test[test > 5]
rrr = test[test > 5]
test2 = c("abc", 1)
test3 = 6
5 * (test3 == 6) + 4 * (test3 != 6)
test3 = 5
5 * (test3 == 6) + 4 * (test3 != 6)
rrr = test[test > 2]
test[test > 2][1]
insert_into_tradesbook <- function(tradesbook, time, sym, qty, side, price, openclose, pnl){
}
handle_cancels <- function(cancelorders, orderbook){
#returns execution messages
}
handle_cancels(1, 2)
handle_cancels(1, 2)
cat(handle_cancels(1, 2))
handle_cancels(1, 2)
handle_cancels(1, 2)
handle_cancels <- function(cancelorders, orderbook){
#returns execution messages
cat(cancelorders)
}
handle_cancels(1, 2)
handle_cancels(orderbook = 2, cancelorders = 1)
1.334^2
exp(-1.334^2) / sqrt(2*pi)
exp(-1.334^2/2) / sqrt(2*pi)
exp(-1.334^2/2) / sqrt(2*pi) / 45 / 0.15 / 0.5
5 * 0.04855239
exp(-0.8931^2/2) / sqrt(2*pi) / 45 / 0.15 / sqrt(0.5)
5 * 0.04855239 / 0.05609429
4.32775 * 0.8141 - 5 * 0.9089
source('~/APS490/APS490RBCCM/main.r', echo=TRUE)
setwd("~/APS490/APS490RBCCM")
source('~/APS490/APS490RBCCM/main.r', echo=TRUE)
env <- global_tables
symbol = "BNS"
time_interval = 5
num_states = 4
datatable_name <- paste(symbol, Con_Data_Tick_Suffix, sep = "")
timestamp <- env[[datatable_name]][[Con_Data_ColName_Date]]
value <- env[[datatable_name]][[Con_Data_ColName_Value]]
volume <- env[[datatable_name]][[Con_Data_ColName_Volume]]
#timestamp converted into integer represents seconds
#9:30 EDT mod 86400 = 48600, 9:30 EST mod 86400 = 48600+ 3600
#trading day is 23400s long
#split the data into days
#assume there is always data at 15:59
cat('Retrieving data \n')
time_since_open <- rep(0, length(timestamp))
num_of_minutes <- 390
for (i in 1: length(timestamp))
time_since_open[i] <- get_time_since_open(timestamp[i])
N <- sum(time_since_open == 0)
start_of_day_indices <- (1:length(timestamp))[time_since_open == 0]
num_of_lines_per_day <- start_of_day_indices[2] - start_of_day_indices[1]
value_by_day <- matrix(-1, nrow = N, ncol = num_of_minutes)
volume_by_day <- matrix(-1, nrow = N, ncol = num_of_minutes)
for (i in 1:N){
value_by_day[i,] = value[(i - 1) * num_of_lines_per_day + (1:num_of_minutes)]
volume_by_day[i,] = volume[(i - 1) * num_of_lines_per_day + (1:num_of_minutes)]
}
#time_interval = 5 #denote minutes
Tnum = 23400 / (time_interval * 60)
t_marker <- (time_interval * 60) * (1: Tnum)
VWAP <- matrix(0, nrow = N, ncol = Tnum + 1)
interval_volume = matrix(0, nrow = N, ncol = Tnum)
VWAP[,1] = env[[datatable_name]][[Con_Data_ColName_Open]][time_since_open == 0]
for (n in 1:N){
interval_volume[n,] <- colSums(matrix(volume_by_day[n,], nrow = time_interval, ncol = Tnum))
VWAP[n,2:(Tnum + 1)] <- colSums(matrix(value_by_day[n,], nrow = time_interval, ncol = Tnum)) / interval_volume[n,]
#correct NaN prices. This is caused by the interval volume being 0. In this case VWAP is the same
#as the last time period.
for(t in 2:(Tnum + 1)){
if (is.nan(VWAP[n, t])){
VWAP[n, t] = VWAP[n, t - 1]
}
}
}
p_increments <- VWAP[,2:(Tnum + 1)] - VWAP[,1:Tnum]
# remove outliers
training_days <- c(1:60)
#qqnorm(as.vector(log(interval_volume[1:60,])))
p_increments_training <- p_increments[training_days,]
volume_training <- interval_volume[training_days,]
cat('get parameter estimates \n')
estimates <- get_params_estimates(p_increments_training, volume_training, num_states)
A <- t(matrix(data.matrix(estimates[["A"]]), nrow = num_states, ncol = num_states))
mu <- t(data.matrix(estimates[["mu"]]))
sigma_mu <- t(data.matrix(estimates[["sigma_mu"]]))
eta <- t(data.matrix(estimates[["eta"]]))
sigma_eta <- t(data.matrix((estimates[["sigma_eta"]])))
start_time <- timestamp[1]
end_time <- timestamp[length(timestamp) - 1]
cat('run performance testing \n')
predictions <- performance_test(start_time, end_time, env, symbol, time_interval, num_states, A, mu, sigma_mu, eta, sigma_eta)
source('strategy_hmm.r')
predictions <- performance_test(start_time, end_time, env, symbol, time_interval, num_states, A, mu, sigma_mu, eta, sigma_eta)
source('strategy_hmm.r')
predictions <- performance_test(start_time, end_time, env, symbol, time_interval, num_states, A, mu, sigma_mu, eta, sigma_eta)
test_HMMM(global_tables, 'BNS', 5, 4)
source('strategy_hmm.r')
predictions <- performance_test(start_time, end_time, env, symbol, time_interval, num_states, A, mu, sigma_mu, eta, sigma_eta)
predictions <- performance_test(start_time, end_time, env, symbol, time_interval, num_states, A, mu, sigma_mu, eta, sigma_eta)
predictions <- performance_test(start_time, end_time, env, symbol, time_interval, num_states, A, mu, sigma_mu, eta, sigma_eta)
source('strategy_hmm.r')
source('strategy_hmm.r')
predictions <- performance_test(start_time, end_time, env, symbol, time_interval, num_states, A, mu, sigma_mu, eta, sigma_eta)
source('strategy_hmm.r')
predictions <- performance_test(start_time, end_time, env, symbol, time_interval, num_states, A, mu, sigma_mu, eta, sigma_eta)
current_time
source('strategy_hmm.r')
predictions <- performance_test(start_time, end_time, env, symbol, time_interval, num_states, A, mu, sigma_mu, eta, sigma_eta)
source('strategy_hmm.r')
predictions <- performance_test(start_time, end_time, env, symbol, time_interval, num_states, A, mu, sigma_mu, eta, sigma_eta)
current_time > as.POSIXct("2015-05-16 08:30:00", tz = "EDT")
current_time
as.POSIXct("2015-05-16 08:30:00", tz = "EDT")
as.POSIXct("2015-05-16 08:30:00 EDT")
source('strategy_hmm.r')
predictions <- performance_test(start_time, end_time, env, symbol, time_interval, num_states, A, mu, sigma_mu, eta, sigma_eta)
source('strategy_hmm.r')
predictions <- performance_test(start_time, end_time, env, symbol, time_interval, num_states, A, mu, sigma_mu, eta, sigma_eta)
source('strategy_hmm.r')
predictions <- performance_test(start_time, end_time, env, symbol, time_interval, num_states, A, mu, sigma_mu, eta, sigma_eta)
source('strategy_hmm.r')
predictions <- performance_test(start_time, end_time, env, symbol, time_interval, num_states, A, mu, sigma_mu, eta, sigma_eta)
predictions <- performance_test(start_time, end_time, env, symbol, time_interval, num_states, A, mu, sigma_mu, eta, sigma_eta)
time()
time
env[["BNS_tick"]][["Dates"]][1001:2000]
env[["BNS_tick"]][["Date"]][1001:2000]
source('backtest_lib.r')
predictions <- performance_test(start_time, end_time, env, symbol, time_interval, num_states, A, mu, sigma_mu, eta, sigma_eta)
predictions <- performance_test(start_time, end_time, env, symbol, time_interval, num_states, A, mu, sigma_mu, eta, sigma_eta)
source('backtest_lib.r')
source('strategy_hmm.r')
predictions <- performance_test(start_time, end_time, env, symbol, time_interval, num_states, A, mu, sigma_mu, eta, sigma_eta)
j
source('backtest_lib.r')
predictions <- performance_test(start_time, end_time, env, symbol, time_interval, num_states, A, mu, sigma_mu, eta, sigma_eta)
source('strategy_hmm.r')
predictions <- performance_test(start_time, end_time, env, symbol, time_interval, num_states, A, mu, sigma_mu, eta, sigma_eta)
source('backtest_lib.r')
predictions <- performance_test(start_time, end_time, env, symbol, time_interval, num_states, A, mu, sigma_mu, eta, sigma_eta)
source('backtest_lib.r')
predictions <- performance_test(start_time, end_time, env, symbol, time_interval, num_states, A, mu, sigma_mu, eta, sigma_eta)
source('strategy_hmm.r')
source('strategy_hmm.r')
predictions <- performance_test(start_time, end_time, env, symbol, time_interval, num_states, A, mu, sigma_mu, eta, sigma_eta)
source('strategy_hmm.r')
predictions <- performance_test(start_time, end_time, env, symbol, time_interval, num_states, A, mu, sigma_mu, eta, sigma_eta)
start_time
source('strategy_hmm.r')
predictions <- performance_test(start_time, end_time, env, symbol, time_interval, num_states, A, mu, sigma_mu, eta, sigma_eta)
source('strategy_hmm.r')
predictions <- performance_test(start_time, end_time, env, symbol, time_interval, num_states, A, mu, sigma_mu, eta, sigma_eta)
source('strategy_hmm.r')
predictions <- performance_test(start_time, end_time, env, symbol, time_interval, num_states, A, mu, sigma_mu, eta, sigma_eta)
predictions <- performance_test(start_time, end_time, env, symbol, time_interval, num_states, A, mu, sigma_mu, eta, sigma_eta)
source('strategy_hmm.r')
start_time <- '2015-05-25 9:30:00 EDT'
start_time <- as.POSIXct('2015-05-25 9:30:00 EDT')
predictions <- performance_test(start_time, end_time, env, symbol, time_interval, num_states, A, mu, sigma_mu, eta, sigma_eta)
source('strategy_hmm.r')
predictions <- performance_test(start_time, end_time, env, symbol, time_interval, num_states, A, mu, sigma_mu, eta, sigma_eta)
log_alpha
calc_forward(num_states, 1, length(interval_volume), A, p_increment, mu, sigma_mu, log(interval_volume), eta, sigma_eta)
calc_forward(num_states, 1, length(interval_volume), A, p_increment, mu, sigma_mu, log(interval_volume), eta, sigma_eta)
log_alpha
log_alpha
log_alpha
log_alpha
log_diff
t(log(t(log_diff) %*% A))
matrix(apply(matrix(log_alpha[, t-1, ], nrow = num_states, ncol = N), 2, max), nrow = num_states, ncol = dim(volume)[1], byrow = TRUE)
state_log_lik(matrix(p_increment[,t], nrow = num_states, ncol = dim(p_increment)[1], byrow = TRUE),
mu, sigma_mu,
matrix(volume[,t], nrow = num_states, ncol = dim(volume)[1], byrow = TRUE),
eta, sigma_eta)
matrix(p_increment[,t], nrow = num_states, ncol = dim(p_increment)[1], byrow = TRUE)
p_increment
p_increment
VWAP_prices
last_interval_VWAP_price
cumul_volume
env[["BNS_tick"]][["Date"]][2500:2700]
env[["BNS_tick"]][["Date"]][2700:2900]
env[["BNS_tick"]][2780:2800,]
source('strategy_hmm.r')
test_HMMM(global_tables, 'BNS', 5, 4)
source('strategy_hmm.r')
system.time({test_HMMM(global_tables, 'BNS', 5, 4)})
env <- global_tables
symbol = "BNS"
time_interval = 5
num_states = 4
datatable_name <- paste(symbol, Con_Data_Tick_Suffix, sep = "")
timestamp <- env[[datatable_name]][[Con_Data_ColName_Date]]
value <- env[[datatable_name]][[Con_Data_ColName_Value]]
volume <- env[[datatable_name]][[Con_Data_ColName_Volume]]
#timestamp converted into integer represents seconds
#9:30 EDT mod 86400 = 48600, 9:30 EST mod 86400 = 48600+ 3600
#trading day is 23400s long
#split the data into days
#assume there is always data at 15:59
cat('Retrieving data \n')
time_since_open <- rep(0, length(timestamp))
num_of_minutes <- 390
for (i in 1: length(timestamp))
time_since_open[i] <- get_time_since_open(timestamp[i])
N <- sum(time_since_open == 0)
start_of_day_indices <- (1:length(timestamp))[time_since_open == 0]
num_of_lines_per_day <- start_of_day_indices[2] - start_of_day_indices[1]
value_by_day <- matrix(-1, nrow = N, ncol = num_of_minutes)
volume_by_day <- matrix(-1, nrow = N, ncol = num_of_minutes)
for (i in 1:N){
value_by_day[i,] = value[(i - 1) * num_of_lines_per_day + (1:num_of_minutes)]
volume_by_day[i,] = volume[(i - 1) * num_of_lines_per_day + (1:num_of_minutes)]
}
#time_interval = 5 #denote minutes
Tnum = 23400 / (time_interval * 60)
t_marker <- (time_interval * 60) * (1: Tnum)
VWAP <- matrix(0, nrow = N, ncol = Tnum + 1)
interval_volume = matrix(0, nrow = N, ncol = Tnum)
VWAP[,1] = env[[datatable_name]][[Con_Data_ColName_Open]][time_since_open == 0]
for (n in 1:N){
interval_volume[n,] <- colSums(matrix(volume_by_day[n,], nrow = time_interval, ncol = Tnum))
VWAP[n,2:(Tnum + 1)] <- colSums(matrix(value_by_day[n,], nrow = time_interval, ncol = Tnum)) / interval_volume[n,]
#correct NaN prices. This is caused by the interval volume being 0. In this case VWAP is the same
#as the last time period.
for(t in 2:(Tnum + 1)){
if (is.nan(VWAP[n, t])){
VWAP[n, t] = VWAP[n, t - 1]
}
}
}
p_increments <- VWAP[,2:(Tnum + 1)] - VWAP[,1:Tnum]
# remove outliers
training_days <- c(1:60)
#qqnorm(as.vector(log(interval_volume[1:60,])))
p_increments_training <- p_increments[training_days,]
volume_training <- interval_volume[training_days,]
cat('get parameter estimates \n')
estimates <- get_params_estimates(p_increments_training, volume_training, num_states)
A <- t(matrix(data.matrix(estimates[["A"]]), nrow = num_states, ncol = num_states))
mu <- t(data.matrix(estimates[["mu"]]))
sigma_mu <- t(data.matrix(estimates[["sigma_mu"]]))
eta <- t(data.matrix(estimates[["eta"]]))
sigma_eta <- t(data.matrix((estimates[["sigma_eta"]])))
start_time <- timestamp[1]
start_time <- as.POSIXct('2015-05-25 9:30:00 EDT')
end_time <- timestamp[length(timestamp) - 1]
system.time({predictions <- performance_test(start_time, end_time, env, symbol, time_interval, num_states, A, mu, sigma_mu, eta, sigma_eta)})
predictions
p_increments > 0
actual_directions <- matrix(NA, N, Tnum)
for (i in 1:N){
for (t in 1:Tnum){
if (p_increments[i,t] > 0){
actual_directions[i,t] = TRUE
}
else if(p_increments[i,t] > 0){
actual_directions[i,t] = FALSE
}
else{
}
}
}
nrow(predictions)
comparison <- predictions[,2:Tnum] == actual_directions[1:nrow(predictions),2:Tnum]
comparison
predictions[1,]
actual_directions[1,]
p_increments[1,]
actual_directions <- matrix(NA, N, Tnum)
for (i in 1:N){
for (t in 1:Tnum){
if (p_increments[i,t] > 0){
actual_directions[i,t] = TRUE
}
else if(p_increments[i,t] < 0){
actual_directions[i,t] = FALSE
}
else{
}
}
}
predictions[1,]
actual_directions[1,]
predictions[1,] == actual_directions[1,]
sum(predictions[1,] == actual_directions[1,]) / 77
sum(predictions[1,2:78] == actual_directions[1,2:78]) / 77
comparison <- predictions[,2:Tnum] == actual_directions[1:nrow(predictions),2:Tnum]
comparison
sum(comparison)
sum(is.na(comparison))
sum(comparison[!is.na(comparison)])
sum(comparison[!is.na(comparison)]) / (nrow(comparison) * ncol(comparison))
