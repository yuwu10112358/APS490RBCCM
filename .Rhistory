fill_msgs[, Con_FieldName_Time] <- rep(timestamp, nrow(ready_orders_list))
return (fill_msgs)
}
#tested
insert_into_orderbook <-function(limit_orders, env, orderbook_name){
#orderbook is a referene (pointer in an environment), and changes are meant to be permanent
#insert limit orders into orderbook, return nothing
new_entries <- data.frame((matrix(0, nrow(limit_orders), length(orderbook_spec))))
colnames(new_entries) <- orderbook_spec
new_entries[, Con_FieldName_OrdID] <- limit_orders[, Con_FieldName_OrdID]
new_entries[, Con_FieldName_Time] <- limit_orders[, Con_FieldName_Time]
new_entries[, Con_FieldName_Sym] <- limit_orders[, Con_FieldName_Sym]
new_entries[, Con_FieldName_Price] <- limit_orders[, Con_FieldName_Price]
new_entries[, Con_FieldName_Qty] <- limit_orders[, Con_FieldName_Qty]
new_entries[, Con_FieldName_Side] <- limit_orders[, Con_FieldName_Side]
new_entries[, Con_FieldName_OrdType] <- limit_orders[, Con_FieldName_OrdType]
env[[orderbook_name]] <- rbind(env[[orderbook_name]], new_entries)
}
#tested
insert_into_tradesbook <- function(env, tradesbook_name, time, sym, qty, side, price, openclose, pnl){
new_line_index <- nrow(env[[tradesbook_name]]) + 1
env[[tradesbook_name]][new_line_index, Con_FieldName_Time] <- time
env[[tradesbook_name]][new_line_index, Con_FieldName_Sym] <- sym
env[[tradesbook_name]][new_line_index, Con_FieldName_Side] <- side
env[[tradesbook_name]][new_line_index, Con_FieldName_Qty] <- qty
env[[tradesbook_name]][new_line_index, Con_FieldName_Price] <- price
env[[tradesbook_name]][new_line_index, Con_FieldName_OpenClose] <- openclose
env[[tradesbook_name]][new_line_index, Con_FieldName_Pnl] <- pnl
}
handle_cancels <- function(cancelorders, orderbook, timestamp){
#returns execution messages
#cat(cancelorders)
}
handle_replaces <- function(replaceorders, orderbook, timestamp){
#returns execution messages
}
get_time_since_open <- function(timestamp){
if (strftime(timestamp, format = "%Z") == "EDT")
return ((as.numeric(timestamp) %% 86400) - 48600)
else
return ((as.numeric(timestamp) %% 86400) - 52200)
}
# ################################################
init_cash = 100000
#global_variables: position matrices, trade matrices, ourdata, order book
#order format: msgtype, symbol, price, quantity, side, ordtype, orderID, time
#execution message format: orderID, Execstatus, symbol, quantity, avg price, side, time
#Execstatus can be the following: filled, replaced, cancelled, replacereject?, cancelreject
#order book format: orderID, time, symbol, price, quantity, side, ordtype
#trade matrix format: time, symbol, side, quantity, price, open/close, pnl
#position matrix: time, asset, #of shares, book value, market value,
datafile_name = "../data/TSXdatafile.xls"
global_tables = new.env()
global_tables[[Con_GlobalVarName_LOB]]<- data.frame(matrix(0, 0, length(orderbook_spec)))
colnames(global_tables[[Con_GlobalVarName_LOB]]) <- orderbook_spec
#the position book is a list of data frames
init_pos <- data.frame(matrix(0, 1, length(positionbook_spec)))
colnames(init_pos) <- positionbook_spec
init_pos[,Con_FieldName_Sym] = Con_Sym_Cash
init_pos[,c(Con_FieldName_Qty, Con_FieldName_BookVal, Con_FieldName_MktVal)] = init_cash
global_tables[[Con_GlobalVarName_PositionBook]] <- list(init_pos)
names(global_tables[[Con_GlobalVarName_PositionBook]])[1] = 0
global_tables[[Con_GlobalVarName_TradesBook]] <- data.frame(matrix(0, 0, length(tradesbook_spec)))
colnames(global_tables[[Con_GlobalVarName_TradesBook]]) <- tradesbook_spec
global_tables[[Con_GlobalVarName_MktPrice]] <- list(vector())
global_tables[[Con_GlobalVarName_BidPrice]] <- list(vector())
global_tables[[Con_GlobalVarName_AskPrice]] <- list(vector())
global_tables[[Con_GlobalVarName_ListDates]] <- list(vector())
import_data(global_tables)
import_data <- function(env){
env[["AC_ask"]] <- read.csv("AC_ask.csv")
env[["AC_ask"]]$Date <- as.POSIXct(env[["AC_ask"]]$Date)
env[["AC_bid"]] <- read.csv("AC_bid.csv")
env[["AC_bid"]]$Date <- as.POSIXct(env[["AC_bid"]]$Date)
env[["AC_tick"]] <- read.csv("AC_tick.csv")
env[["AC_tick"]]$Date <- as.POSIXct(env[["AC_tick"]]$Date)
env[["BNS_ask"]] <- read.csv("BNS_ask.csv")
env[["BNS_ask"]]$Date <- as.POSIXct(env[["BNS_ask"]]$Date)
env[["BNS_bid"]] <- read.csv("BNS_bid.csv")
env[["BNS_bid"]]$Date <- as.POSIXct(env[["BNS_bid"]]$Date)
env[["BNS_tick"]] <- read.csv("BNS_tick.csv")
env[["BNS_tick"]]$Date <- as.POSIXct(env[["BNS_tick"]]$Date)
env[["BMO_ask"]] <- read.csv("BMO_ask.csv")
env[["BMO_ask"]]$Date <- as.POSIXct(env[["BMO_ask"]]$Date)
env[["BMO_bid"]] <- read.csv("BMO_bid.csv")
env[["BMO_bid"]]$Date <- as.POSIXct(env[["BMO_bid"]]$Date)
env[["BMO_tick"]] <- read.csv("BMO_tick.csv")
env[["BMO_tick"]]$Date <- as.POSIXct(env[["BMO_tick"]]$Date)
Stocks <- c("AC", "BNS", "BMO")
EquityList <- c("tick", "ask", "bid")
# removes N/A fields and only keeps times when the market is open
for (i in Stocks){
for (Name in EquityList){
nm <- paste(i,Name,sep="_")
Opentime <- as.POSIXct("2000-01-01 09:30:00", tz = "EST")
Opentime <-strftime(Opentime, format="%H:%M:%S")
Closetime <- as.POSIXct("2000-01-01 16:00:00", tz = "EST")
Closetime <-strftime(Closetime, format="%H:%M:%S")
row_to_keep <- logical(length = nrow(env[[nm]]) )
maxrow <- nrow(env[[nm]])
env[[nm]] = env[[nm]][complete.cases(env[[nm]][1:maxrow,] ) ,]
for (j in 1:nrow(env[[nm]])){
temp <- strftime(env[[nm]][j,1], format="%H:%M:%S")
if ( temp >= Opentime && temp <= Closetime){
row_to_keep[j] <- TRUE
} else{
row_to_keep[j] <- FALSE
}
}
env[[nm]] = env[[nm]][row_to_keep,]
}
}
# fills in missing times with the previous minute's market information
for (stock in Stocks){
for (name in EquityList){
nm <- paste(stock,name,sep="_")
col_nms <- colnames(env[[nm]])
list_times_vec <- data.frame()
env[["list_dates"]] <- as.data.frame(unique(as.Date(env[[nm]][, "Date"])))
list_dates <- env[["list_dates"]]
for (i in 1:nrow(list_dates)){
st <- as.POSIXct(paste(list_dates[i,1], "09:30:00"), origin = "1970-01-01")
en <- as.POSIXct(paste(list_dates[i,1], "16:00:00"), origin = "1970-01-01")
list_times_vec <- rbind(list_times_vec, data.frame(seq(from = st, to = en, by = "min")))
}
dates_list <- list_times_vec
mtrix <- matrix(0, nrow(list_times_vec), (ncol(env[[nm]])-1))
list_times_vec <- cbind(list_times_vec, mtrix)
colnames(list_times_vec) <- col_nms
testy <- merge(list_times_vec, env[[nm]], by = "Date", all = TRUE)
testy <- testy[,9:15]
na_rows <- rownames(subset(testy,is.na(testy$OPEN.y)))
for (rw in na_rows){
rw <- as.integer(rw)
testy[rw,1:4] <- testy[rw-1,1:4]
}
testy[is.na(testy)] <- 0
new_data_final <- cbind(dates_list, testy)
env[[nm]] <- new_data_final
colnames(env[[nm]]) <- col_nms
}
}
# assign each df in the environment to a variable
for (stock in Stocks){
for (name in EquityList){
stock_data <- paste(stock,name,sep="_")
assign(paste(stock,name,sep="_"), env[[stock_data]])
}
}
}
import_data(global_tables)
EquityList <- c("tick", "ask", "bid")
env <- global_tables
tradesbook <- read.csv("tradebookipr.csv", header = TRUE)
positionbook <- read.csv("positionbookipr.csv", header = TRUE)
tradesbook$Timestamp <- as.POSIXct(tradesbook$Timestamp)
positionbook$Timestamp <- as.POSIXct(positionbook$Timestamp)
tradesbook$Symbol <- as.character(tradesbook$Symbol)
# find the unique stocks that have been traded over the duration
stock_list <- unique(as.vector(tradesbook$Symbol))
# Set up the data frame which will store the cumulative pnl values for each stock and portfolio
Pnl_df <- data.frame(Symbol=character(), DateTime=as.Date(character()), BidAskPrice=character(),
BookValue=integer(), Side=integer(), Quantity = integer(),
Open.Close = character(), PnLStock = integer(), Cash = integer(),
Portfolio = integer(), PnLPortfolio = integer())
# loop through all the stocks that have been traded
for (i in 1:length(stock_list)){
stock_name <- stock_list[i]
# filter the tradesbook for only the selected stock
totalqty_owned <- 0
filtered_tradesbook <- subset(tradesbook, Symbol == stock_name)
rownames(filtered_tradesbook) <- 1:nrow(filtered_tradesbook)
# loop through all the trades made in the tradesbook
for (j in 1:nrow(filtered_tradesbook)){
if (j == nrow(filtered_tradesbook)){
break
}
curr_side <- filtered_tradesbook$Side[j]
next_side <- filtered_tradesbook$Side[j+1]
# change the period back to a back slash since the csv changes the period to a back slash
curr_pos <- filtered_tradesbook$Open.Close[j]
next_pos <- filtered_tradesbook$Open.Close[j+1]
start_time_date <- filtered_tradesbook[j, "Timestamp"]
end_time_date <- filtered_tradesbook[j + 1, "Timestamp"]
# re-order so trades are closed before new trades are opened
if (end_time_date == start_time_date & next_pos == "Close"){
curr_line <- filtered_tradesbook[j, ]
next_line <- filtered_tradesbook[j+1, ]
filtered_tradesbook[j, ] <- next_line
filtered_tradesbook[j+1, ] <- curr_line
}
book_value <- positionbook[positionbook$Timestamp == start_time_date & positionbook$Symbol == stock_name, ]["BookValue"] /
positionbook[positionbook$Timestamp == start_time_date & positionbook$Symbol == stock_name, ]["Quantity"]
# add the quantity owned at each time step
if (curr_side == 2){
totalqty_owned <- totalqty_owned - abs(filtered_tradesbook[j, "Quantity"])
filtered_tradesbook[j, "QuantityOwned"] <- totalqty_owned
} else if (curr_side == 1){
totalqty_owned <- totalqty_owned + abs(filtered_tradesbook[j, "Quantity"])
filtered_tradesbook[j, "QuantityOwned"] <- totalqty_owned
}
qty_owned <- filtered_tradesbook[j, "QuantityOwned"]
if (start_time_date == end_time_date){
if (j == (nrow(filtered_tradesbook)-1)){
break
}
}
if (curr_side == 1 && curr_pos == "Open"){
stock_data <- paste(stock_name,EquityList[2],sep="_")
stock_matrix <- env[[stock_data]]
type <- "bid"
} else if (curr_side == 2 && curr_pos == "Open"){
stock_data <- paste(stock_name,EquityList[3],sep="_")
stock_matrix <- env[[stock_data]]
type <- "ask"
} # else if (curr_pos == "Close") {
#next
#}
for (k in 1:NROW(stock_matrix)){
if (stock_matrix[k, "Date"] > end_time_date) {
break
} else if (stock_matrix[k,"Date"] >= start_time_date){
# must clarify what price would we realize profits at (i.e what is market value at a given time)
# add part in future if trading more than one stock, must access the correct market data
# depending on what the value of stock_name is
if (type == "ask") {
# if we shorted (curr_pos = 2), then the market value is the current ask price at LOW (buy low)
# assumed that the ask and bid prices are identical to tick (i.e same number of rows)
stock_data <- paste(stock_name,EquityList[2],sep="_")
bidask_matrix <- env[[stock_data]]
bidask_price <- bidask_matrix[k, "LOW"]
} else {
# if we longed (curr_pos = 1), then the market value is the current bid price at HIGH (sell high)
stock_data <- paste(stock_name,EquityList[3],sep="_")
bidask_matrix <- env[[stock_data]]
bidask_price <- bidask_matrix[k, "HIGH"]
}
#           if (stock_matrix[k, "Date"] == end_time_date) {
#             curr_pos <- "Close"
#             if (curr_side == 1){
#               curr_side == 2
#             } else {
#               curr_side == 1
#             }
#           }
Pnl_df <- rbind(Pnl_df, data.frame(Symbol = stock_name, DateTime = stock_matrix[k, "Date"],
BidAskPrice = bidask_price,
BookValue = book_value, Side = curr_side,
Quantity = qty_owned, OpenClose = curr_pos))
}
}
}
}
View(Pnl_df)
# find the unique stocks that have been traded over the duration
stock_list <- unique(as.vector(tradesbook$Symbol))
# Set up the data frame which will store the cumulative pnl values for each stock and portfolio
Pnl_df <- data.frame(Symbol=character(), DateTime=as.Date(character()), BidAskPrice=character(),
BookValue=integer(), Side=integer(), Quantity = integer(),
Open.Close = character(), PnLStock = integer(), Cash = integer(),
Portfolio = integer(), PnLPortfolio = integer())
# loop through all the stocks that have been traded
for (i in 1:length(stock_list)){
stock_name <- stock_list[i]
# filter the tradesbook for only the selected stock
totalqty_owned <- 0
filtered_tradesbook <- subset(tradesbook, Symbol == stock_name)
rownames(filtered_tradesbook) <- 1:nrow(filtered_tradesbook)
# loop through all the trades made in the tradesbook
for (j in 1:nrow(filtered_tradesbook)){
if (j == nrow(filtered_tradesbook)){
break
}
curr_side <- filtered_tradesbook$Side[j]
next_side <- filtered_tradesbook$Side[j+1]
# change the period back to a back slash since the csv changes the period to a back slash
curr_pos <- filtered_tradesbook$Open.Close[j]
next_pos <- filtered_tradesbook$Open.Close[j+1]
start_time_date <- filtered_tradesbook[j, "Timestamp"]
end_time_date <- filtered_tradesbook[j + 1, "Timestamp"]
# re-order so trades are closed before new trades are opened
if (end_time_date == start_time_date & next_pos == "Close"){
curr_line <- filtered_tradesbook[j, ]
next_line <- filtered_tradesbook[j+1, ]
filtered_tradesbook[j, ] <- next_line
filtered_tradesbook[j+1, ] <- curr_line
}
book_value <- positionbook[positionbook$Timestamp == start_time_date & positionbook$Symbol == stock_name, ]["BookValue"] /
positionbook[positionbook$Timestamp == start_time_date & positionbook$Symbol == stock_name, ]["Quantity"]
# add the quantity owned at each time step
if (curr_side == 2){
totalqty_owned <- totalqty_owned - abs(filtered_tradesbook[j, "Quantity"])
filtered_tradesbook[j, "QuantityOwned"] <- totalqty_owned
} else if (curr_side == 1){
totalqty_owned <- totalqty_owned + abs(filtered_tradesbook[j, "Quantity"])
filtered_tradesbook[j, "QuantityOwned"] <- totalqty_owned
}
qty_owned <- filtered_tradesbook[j, "QuantityOwned"]
if (start_time_date == end_time_date){
if (j == (nrow(filtered_tradesbook)-1)){
break
}
}
if (curr_side == 1 && curr_pos == "Open"){
stock_data <- paste(stock_name,EquityList[2],sep="_")
stock_matrix <- env[[stock_data]]
type <- "bid"
} else if (curr_side == 2 && curr_pos == "Open"){
stock_data <- paste(stock_name,EquityList[3],sep="_")
stock_matrix <- env[[stock_data]]
type <- "ask"
} # else if (curr_pos == "Close") {
#next
#}
for (k in 1:NROW(stock_matrix)){
if (stock_matrix[k, "Date"] > end_time_date) {
break
} else if (stock_matrix[k,"Date"] >= start_time_date){
# must clarify what price would we realize profits at (i.e what is market value at a given time)
# add part in future if trading more than one stock, must access the correct market data
# depending on what the value of stock_name is
if (type == "ask") {
# if we shorted (curr_pos = 2), then the market value is the current ask price at LOW (buy low)
# assumed that the ask and bid prices are identical to tick (i.e same number of rows)
stock_data <- paste(stock_name,EquityList[2],sep="_")
bidask_matrix <- env[[stock_data]]
bidask_price <- bidask_matrix[k, "LOW"]
} else {
# if we longed (curr_pos = 1), then the market value is the current bid price at HIGH (sell high)
stock_data <- paste(stock_name,EquityList[3],sep="_")
bidask_matrix <- env[[stock_data]]
bidask_price <- bidask_matrix[k, "HIGH"]
}
#           if (stock_matrix[k, "Date"] == end_time_date) {
#             curr_pos <- "Close"
#             if (curr_side == 1){
#               curr_side == 2
#             } else {
#               curr_side == 1
#             }
#           }
Pnl_df <- rbind(Pnl_df, data.frame(Symbol = stock_name, DateTime = stock_matrix[k, "Date"],
BidAskPrice = bidask_price,
BookValue = book_value, Side = curr_side,
Quantity = qty_owned, OpenClose = curr_pos))
}
}
}
}
View(Pnl_df)
Pnl_df <- Pnl_df[order(Pnl_df$DateTime, decreasing = FALSE), ]
# record the cash in the account at each time step, pulling from the positionbook.
for (i in 1:NROW(Pnl_df)){
curr_date_time <- Pnl_df[i, "DateTime"]
# start for loop on second element since the first is at time 0 and records the default cash position
for (j in 2:NROW(positionbook)){
if (positionbook[j, "Timestamp"] == curr_date_time && positionbook[j, "Symbol"] == "Cash"){
Pnl_df[i, "Cash"] <- positionbook[j, "BookValue"]
}
}
# if there is no datetime match in the positions matrix, this means that there was no position
# taken at the time and therefore cash is just equal to the previous time step (no change)
if (is.na(Pnl_df[i, "Cash"])){
Pnl_df[i, "Cash"] <- Pnl_df[i-1, "Cash"]
}
}
# calculate the cumulative PnL of each stock
for (i in 1:NROW(Pnl_df)){
curr_symbol <- as.character(Pnl_df[i, "Symbol"])
prev_symbol <- as.character(Pnl_df[i-1, "Symbol"])
curr_side <- Pnl_df[i, "Side"]
# check if there is a 0 in BidAskPrice Column
if (Pnl_df[i, "BidAskPrice"] == 0){
if (curr_symbol == prev_symbol){
Pnl_df[i, "BidAskPrice"] <- Pnl_df[i-1, "BidAskPrice"]
} else {
Pnl_df[i, "BidAskPrice"] <- Pnl_df[i+1, "BidAskPrice"]
}
}
# multiply by -1 to obtain a posititve quantity
if (curr_side == 1){
curr_pnl <- (Pnl_df[i, "BidAskPrice"] - Pnl_df[i-1, "BidAskPrice"])*Pnl_df[i, "Quantity"]
} else {
# book_value <- Pnl_df[i, "BookValue"]
short_qty <- Pnl_df[i, "Quantity"]*-1
curr_pnl <- (Pnl_df[i, "BidAskPrice"] - Pnl_df[i-1, "BidAskPrice"])*short_qty*-1
}
# find cum. value. Ensure that the cumulative value is only carried from previous if it was the same stock
if (i == 1) {
prev_pnl <- 0
curr_pnl <- 0
} else {
if (curr_symbol == prev_symbol){
prev_pnl <- Pnl_df[i-1, "CumPnLStock"]
} else {
prev_pnl <- 0
curr_pnl <- 0
}
}
Pnl_df[i, "CumPnLStock"] <- prev_pnl + curr_pnl
}
View(Pnl_df)
# output <- function(tradesbook, positionbook, ask_prices, bid_prices, market_data){
EquityList <- c("tick", "ask", "bid")
env <- global_tables
# tradesbook <- global_tables$tradesbook
# positionbook <- global_tables$positionbook
tradesbook <- read.csv("tradebookipr.csv", header = TRUE)
positionbook <- read.csv("positionbookipr.csv", header = TRUE)
tradesbook$Timestamp <- as.POSIXct(tradesbook$Timestamp)
positionbook$Timestamp <- as.POSIXct(positionbook$Timestamp)
tradesbook$Symbol <- as.character(tradesbook$Symbol)
# manipulate positionbook to make it a dataframe (it is received as a list)
positionbook <- do.call(rbind, positionbook)
positionbook <- cbind(Timestamp = rownames(positionbook), positionbook)
rownames(positionbook) <- 1:nrow(positionbook)
positionbook$Timestamp <- sapply(strsplit(as.character(positionbook$Timestamp),".",fixed = TRUE), "[[", 1)
# find the unique stocks that have been traded over the duration
stock_list <- unique(as.vector(tradesbook$Symbol))
# Set up the data frame which will store the cumulative pnl values for each stock and portfolio
Pnl_df <- data.frame(Symbol=character(), DateTime=as.Date(character()), BidAskPrice=character(),
BookValue=integer(), Side=integer(), Quantity = integer(),
Open.Close = character(), PnLStock = integer(), Cash = integer(),
Portfolio = integer(), PnLPortfolio = integer())
# loop through all the stocks that have been traded
for (i in 1:length(stock_list)){
stock_name <- stock_list[i]
# filter the tradesbook for only the selected stock
totalqty_owned <- 0
filtered_tradesbook <- subset(tradesbook, Symbol == stock_name)
rownames(filtered_tradesbook) <- 1:nrow(filtered_tradesbook)
# loop through all the trades made in the tradesbook
for (j in 1:nrow(filtered_tradesbook)){
if (j == nrow(filtered_tradesbook)){
break
}
curr_side <- filtered_tradesbook$Side[j]
next_side <- filtered_tradesbook$Side[j+1]
# change the period back to a back slash since the csv changes the period to a back slash
curr_pos <- filtered_tradesbook$Open.Close[j]
next_pos <- filtered_tradesbook$Open.Close[j+1]
start_time_date <- filtered_tradesbook[j, "Timestamp"]
end_time_date <- filtered_tradesbook[j + 1, "Timestamp"]
# re-order so trades are closed before new trades are opened
if (end_time_date == start_time_date & next_pos == "Close"){
curr_line <- filtered_tradesbook[j, ]
next_line <- filtered_tradesbook[j+1, ]
filtered_tradesbook[j, ] <- next_line
filtered_tradesbook[j+1, ] <- curr_line
}
book_value <- positionbook[positionbook$Timestamp == start_time_date & positionbook$Symbol == stock_name, ]["BookValue"] /
positionbook[positionbook$Timestamp == start_time_date & positionbook$Symbol == stock_name, ]["Quantity"]
# add the quantity owned at each time step
if (curr_side == 2){
totalqty_owned <- totalqty_owned - abs(filtered_tradesbook[j, "Quantity"])
filtered_tradesbook[j, "QuantityOwned"] <- totalqty_owned
} else if (curr_side == 1){
totalqty_owned <- totalqty_owned + abs(filtered_tradesbook[j, "Quantity"])
filtered_tradesbook[j, "QuantityOwned"] <- totalqty_owned
}
qty_owned <- filtered_tradesbook[j, "QuantityOwned"]
if (start_time_date == end_time_date){
if (j == (nrow(filtered_tradesbook)-1)){
break
}
}
if (curr_side == 1 && curr_pos == "Open"){
stock_data <- paste(stock_name,EquityList[2],sep="_")
stock_matrix <- env[[stock_data]]
type <- "bid"
} else if (curr_side == 2 && curr_pos == "Open"){
stock_data <- paste(stock_name,EquityList[3],sep="_")
stock_matrix <- env[[stock_data]]
type <- "ask"
} # else if (curr_pos == "Close") {
#next
#}
for (k in 1:NROW(stock_matrix)){
if (stock_matrix[k, "Date"] > end_time_date) {
break
} else if (stock_matrix[k,"Date"] >= start_time_date){
# must clarify what price would we realize profits at (i.e what is market value at a given time)
# add part in future if trading more than one stock, must access the correct market data
# depending on what the value of stock_name is
if (type == "ask") {
# if we shorted (curr_pos = 2), then the market value is the current ask price at LOW (buy low)
# assumed that the ask and bid prices are identical to tick (i.e same number of rows)
stock_data <- paste(stock_name,EquityList[2],sep="_")
bidask_matrix <- env[[stock_data]]
bidask_price <- bidask_matrix[k, "LOW"]
} else {
# if we longed (curr_pos = 1), then the market value is the current bid price at HIGH (sell high)
stock_data <- paste(stock_name,EquityList[3],sep="_")
bidask_matrix <- env[[stock_data]]
bidask_price <- bidask_matrix[k, "HIGH"]
}
#           if (stock_matrix[k, "Date"] == end_time_date) {
#             curr_pos <- "Close"
#             if (curr_side == 1){
#               curr_side == 2
#             } else {
#               curr_side == 1
#             }
#           }
Pnl_df <- rbind(Pnl_df, data.frame(Symbol = stock_name, DateTime = stock_matrix[k, "Date"],
BidAskPrice = bidask_price,
BookValue = book_value, Side = curr_side,
Quantity = qty_owned, OpenClose = curr_pos))
}
}
}
}
