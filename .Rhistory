load("~/STA410/as1/code/binom-script.r")
cat("\nExample with x =",x,"and n =",n,"\n\n")
x <- 7
n <- 11
cat("\nExample with x =",x,"and n =",n,"\n\n")
source("newton.r")
source("newton.r")
source("bisect.r")
source("bisect.r")
load("~/STA410/as1/code/bisect.r")
source("bisect.r")
source("newton.r")
source("bisect.r")
source('bisect.r')
setwd('C:\Users\Y\Documents\STA410\as1\code')
setwd('C:\\Users\\Y\\Documents\\STA410\\as1\\code')
source('bisect.r')
source('bisect.r')
# Script that uses the bisect and newton functions to find the maximum
setwd("~/STA410/as1/code")
# Script that uses the bisect and newton functions to find the maximum
# likelihood estimate for the "p" parameter of a binomial distribution,
# given one observation, "x".  The "n" parameter is assumed to be known.
source('~/STA410/as1/code/binom-script.r', echo=TRUE)
test = matrix(c(1, -2, -3, 4), nrow =2, ncol = 2)
test
test2 = abs(test)
test2
.machine$eps
.Machine$double.eps
rm(list = ls())
source('mle_as1_lib.r')
x =75
n = 130
x =75
n = 130
m1 = 25
m2 = 25
x1 = 20
x2 = 6
p_ini = c(x1/m1, x2/m2)
p_alt = mle_alt(n, m1, m2, x, x1, x2, p_ini)
p_alt = mle_alt(n, m1, m2, x, x1, x2, p_ini)
p_alt = mle_alt(n, m1, m2, x, x1, x2, p_ini)
source('~/STA410/as1/code/as1.r', echo=TRUE)
p_alt = mle_alt(n, m1, m2, x, x1, x2, p_ini)
source('~/STA410/as1/code/as1.r', echo=TRUE)
warnings()
source('~/STA410/as1/code/as1.r', echo=TRUE)
warnings()
source('~/STA410/as1/code/as1.r', echo=TRUE)
source('~/STA410/as1/code/as1.r', echo=TRUE)
source('~/STA410/as1/code/as1.r', echo=TRUE)
source('~/STA410/as1/code/as1.r', echo=TRUE)
source('~/STA410/as1/code/as1.r', echo=TRUE)
source('~/STA410/as1/code/as1.r', echo=TRUE)
source('~/STA410/as1/code/as1.r', echo=TRUE)
source('~/STA410/as1/code/as1.r', echo=TRUE)
dbinom(x, n, p_ini[1], log = TRUE)
source('~/STA410/as1/code/as1.r', echo=TRUE)
source('~/STA410/as1/code/as1.r', echo=TRUE)
source('~/STA410/as1/code/as1.r', echo=TRUE)
source('~/STA410/as1/code/as1.r', echo=TRUE)
source('~/STA410/as1/code/as1.r', echo=TRUE)
p_alt
log_likelihood_gradient(p_alt, n, m1, m2, x, x1, x2)
p_nlm[gradient]
p_nlm[2]
p_test = p_nlm[2]
unlist(p_test)
p_test = unlist(p_test)
log_likelihood_gradient(p_test, n, m1, m2, x, x1, x2)
log_likelihood(p_test, n, m1, m2, x, x1, x2)
log_likelihood(p_alt, n, m1, m2, x, x1, x2)
p_test1 = p_test + c(1e-8, 0)
p_test2 = p_test - c(1e-8, 0)
dd = log_likelihood(p_test1, n, m1, m2, x, x1, x2) - log_likelihood(p_test2, n, m1, m2, x, x1, x2)
dd / (2e-8)
dbinom(x1, m1, 0.8, log=TRUE)
nlm(function(pp) dbinom(x1, m1, pp, log=TRUE), 0.7)
rr = nlm(function(pp) dbinom(x1, m1, pp, log=TRUE), 0.7)
rr = nlm(function(pp) dbinom(x1, m1, pp, log=TRUE), 0.8)
warnings()
lm(list = ls())
rm(list = ls())
source('~/STA410/as1/code/as1.r', echo=TRUE)
source('~/STA410/as1/code/as1.r', echo=TRUE)
source('~/STA410/as1/code/as1.r', echo=TRUE)
source('~/STA410/as1/code/as1.r', echo=TRUE)
source('~/STA410/as1/code/as1.r', echo=TRUE)
p_nlm
source('~/STA410/as1/code/as1.r', echo=TRUE)
source('~/STA410/as1/code/as1.r', echo=TRUE)
source('~/STA410/as1/code/as1.r', echo=TRUE)
source('~/STA410/as1/code/as1.r', echo=TRUE)
beta_alt
source('~/STA410/as1/code/as1.r', echo=TRUE)
source('~/STA410/as1/code/as1.r', echo=TRUE)
beta_mos
source('~/STA410/as1/code/as1.r', echo=TRUE)
beta_mos
p_mos[2]
test = unlist(p_mos[2])
rm(list = lm())
rm(list = ls())
source('~/STA410/as1/code/as1.r', echo=TRUE)
test = unlist(p_mos[2])
test <- test[test != 0]
source('~/STA410/as1/code/as1.r', echo=TRUE)
source('~/STA410/as1/code/as1.r', echo=TRUE)
beta_mvn
beta_mos
source('~/STA410/as1/code/as1.r', echo=TRUE)
beta_mvn
beta_alt
source('~/STA410/as1/code/as1.r', echo=TRUE)
p_mvn[2]
p_mos[2]
source('~/STA410/as1/code/as1.r', echo=TRUE)
beta_mvn
p_mvn[2]
source('~/STA410/as1/code/as1.r', echo=TRUE)
source('~/STA410/as1/code/as1.r', echo=TRUE)
source('~/STA410/as1/code/as1.r', echo=TRUE)
source('~/STA410/as1/code/as1.r', echo=TRUE)
source('~/STA410/as1/code/as1.r', echo=TRUE)
source('~/STA410/as1/code/as1.r', echo=TRUE)
source('~/STA410/as1/code/as1.r', echo=TRUE)
source('~/STA410/as1/code/as1.r', echo=TRUE)
source('~/STA410/as1/code/as1.r', echo=TRUE)
beta_mvn
source('~/STA410/as1/code/as1.r', echo=TRUE)
beta_mos
source('~/STA410/as1/code/as1.r', echo=TRUE)
beta_mos
beta_alt
p_mvn[2]
source('~/STA410/as1/code/as1.r', echo=TRUE)
beta_mvn
source('~/STA410/as1/code/as1.r', echo=TRUE)
source('~/STA410/as1/code/as1.r', echo=TRUE)
source('~/STA410/as1/code/as1.r', echo=TRUE)
source('~/STA410/as1/code/as1.r', echo=TRUE)
source('~/STA410/as1/code/as1.r', echo=TRUE)
rm(list = ls())
source('~/STA410/as1/code/as1.r', echo=TRUE)
aa
x1
source('as1.r', echo=FALSE)
source('as1.r', echo=FALSE)
source('as1.r', echo=FALSE)
source('as1.r', echo=FALSE)
source('as1.r', echo=FALSE)
p_alt
p_mvn
p_mos
p_nlm
source('as1.r', echo=FALSE)
p_alt
p_mvn
p_mos
p_nlm
source('as1.r', echo=FALSE)
p_alt
p_mvn
p_mos
p_nlm
source('as1.r', echo=FALSE)
source('as1.r', echo=FALSE)
source('as1.r', echo=FALSE)
log_likelihood_hessian(p_alt, n, m1, m2, x, x1, x2)
H = log_likelihood_hessian(p_alt, n, m1, m2, x, x1, x2)
solve(-H)
F = fisher_information(p_alt, n, m1, m2, x, x1, x2)
F
solve(-F)
setwd("~/APS490/APS490RBCCM")
source('constants.r')
source('strategy_lib.r')
source('backtest_lib.r')
init_cash = 100000
#global_variables: position matrices, trade matrices, ourdata, order book
#order format: msgtype, symbol, price, quantity, side, ordtype, orderID, time
#execution message format: orderID, Execstatus, symbol, quantity, avg price, side, time
#Execstatus can be the following: filled, replaced, cancelled, replacereject?, cancelreject
#order book format: orderID, time, symbol, price, quantity, side, ordtype
#trade matrix format: time, symbol, side, quantity, price, open/close, pnl
#position matrix: time, asset, #of shares, book value, market value,
global_tables = new.env()
global_tables$orderbook <- data.frame(matrix(0, 0, length(orderbook_spec)))
colnames(global_tables$orderbook) <- orderbook_spec
init_pos <- data.frame(matrix(0, 1, length(positionbook_spec)))
colnames(init_pos) <- positionbook_spec
init_pos[,Con_FieldName_Sym] = Con_Sym_Cash
init_pos[,c(Con_FieldName_Qty, Con_FieldName_BookVal, Con_FieldName_MktVal)] = init_cash
global_tables$positionbook <- list(init_pos)
names(global_tables$positionbook)[1] = 0
global_tables$tradesbook <- data.frame(matrix(0, 0, length(tradesbook_spec)))
colnames(global_tables$tradesbook) <- tradesbook_spec
global_tables$market_price <- list(vector())
global_tables$bid_price <- list(vector())
global_tables$ask_price <- list(vector())
data_extraction(global_tables, "market_price", "bid_price", "ask_price")
strategy_naive()
output <- output()
yay
source('constants.r')
source('strategy_lib.r')
source('backtest_lib.r')
library(XLConnect)
init_cash = 100000
#global_variables: position matrices, trade matrices, ourdata, order book
#order format: msgtype, symbol, price, quantity, side, ordtype, orderID, time
#execution message format: orderID, Execstatus, symbol, quantity, avg price, side, time
#Execstatus can be the following: filled, replaced, cancelled, replacereject?, cancelreject
#order book format: orderID, time, symbol, price, quantity, side, ordtype
#trade matrix format: time, symbol, side, quantity, price, open/close, pnl
#position matrix: time, asset, #of shares, book value, market value,
global_tables = new.env()
global_tables$orderbook <- data.frame(matrix(0, 0, length(orderbook_spec)))
colnames(global_tables$orderbook) <- orderbook_spec
init_pos <- data.frame(matrix(0, 1, length(positionbook_spec)))
colnames(init_pos) <- positionbook_spec
init_pos[,Con_FieldName_Sym] = Con_Sym_Cash
init_pos[,c(Con_FieldName_Qty, Con_FieldName_BookVal, Con_FieldName_MktVal)] = init_cash
global_tables$positionbook <- list(init_pos)
names(global_tables$positionbook)[1] = 0
global_tables$tradesbook <- data.frame(matrix(0, 0, length(tradesbook_spec)))
colnames(global_tables$tradesbook) <- tradesbook_spec
global_tables$market_price <- list(vector())
global_tables$bid_price <- list(vector())
global_tables$ask_price <- list(vector())
data_extraction(global_tables, "market_price", "bid_price", "ask_price")
strategy_naive()
output <- output()
# yay
global_tables$tick
global_tables$market_price
global_tables$bid_price
global_tables$ask_price
source('constants.r')
source('strategy_lib.r')
source('backtest_lib.r')
library(XLConnect)
library(knitr)
init_cash = 100000
#global_variables: position matrices, trade matrices, ourdata, order book
#order format: msgtype, symbol, price, quantity, side, ordtype, orderID, time
#execution message format: orderID, Execstatus, symbol, quantity, avg price, side, time
#Execstatus can be the following: filled, replaced, cancelled, replacereject?, cancelreject
#order book format: orderID, time, symbol, price, quantity, side, ordtype
#trade matrix format: time, symbol, side, quantity, price, open/close, pnl
#position matrix: time, asset, #of shares, book value, market value,
global_tables = new.env()
global_tables$orderbook <- data.frame(matrix(0, 0, length(orderbook_spec)))
colnames(global_tables$orderbook) <- orderbook_spec
init_pos <- data.frame(matrix(0, 1, length(positionbook_spec)))
colnames(init_pos) <- positionbook_spec
init_pos[,Con_FieldName_Sym] = Con_Sym_Cash
init_pos[,c(Con_FieldName_Qty, Con_FieldName_BookVal, Con_FieldName_MktVal)] = init_cash
global_tables$positionbook <- list(init_pos)
names(global_tables$positionbook)[1] = 0
global_tables$tradesbook <- data.frame(matrix(0, 0, length(tradesbook_spec)))
colnames(global_tables$tradesbook) <- tradesbook_spec
global_tables$market_price <- list(vector())
global_tables$bid_price <- list(vector())
global_tables$ask_price <- list(vector())
data_extraction(global_tables, "market_price", "bid_price", "ask_price")
strategy_naive()
output <- output()
# yay
# Assignment 2 Q1 script
source("assignment2_q1_em.r")
library(knitr)
p <- c(20/25,6/25)
n <- 130
m1 <- 25
m2 <- 25
x <- 75
x1 <- 20
x2 <- 6
assign2_q1_em(p, n, m1, m2, x, x1, x2,100)
source('constants.r')
source('strategy_lib.r')
source('backtest_lib.r')
library(XLConnect)
library(knitr)
opts_chunk$set(fig.path = 'figure/silk-')
init_cash = 100000
#global_variables: position matrices, trade matrices, ourdata, order book
#order format: msgtype, symbol, price, quantity, side, ordtype, orderID, time
#execution message format: orderID, Execstatus, symbol, quantity, avg price, side, time
#Execstatus can be the following: filled, replaced, cancelled, replacereject?, cancelreject
#order book format: orderID, time, symbol, price, quantity, side, ordtype
#trade matrix format: time, symbol, side, quantity, price, open/close, pnl
#position matrix: time, asset, #of shares, book value, market value,
global_tables = new.env()
global_tables$orderbook <- data.frame(matrix(0, 0, length(orderbook_spec)))
colnames(global_tables$orderbook) <- orderbook_spec
init_pos <- data.frame(matrix(0, 1, length(positionbook_spec)))
colnames(init_pos) <- positionbook_spec
init_pos[,Con_FieldName_Sym] = Con_Sym_Cash
init_pos[,c(Con_FieldName_Qty, Con_FieldName_BookVal, Con_FieldName_MktVal)] = init_cash
global_tables$positionbook <- list(init_pos)
names(global_tables$positionbook)[1] = 0
global_tables$tradesbook <- data.frame(matrix(0, 0, length(tradesbook_spec)))
colnames(global_tables$tradesbook) <- tradesbook_spec
global_tables$market_price <- list(vector())
global_tables$bid_price <- list(vector())
global_tables$ask_price <- list(vector())
data_extraction(global_tables, "market_price", "bid_price", "ask_price")
strategy_naive()
output <- output()
# yay
opts_chunk$set(fig.path = 'figure/silk-')
source('constants.r')
source('strategy_lib.r')
source('backtest_lib.r')
library(XLConnect)
library(knitr)
knitr::spin
opts_chunk$set(fig.path = 'figure/silk-')
init_cash = 100000
#global_variables: position matrices, trade matrices, ourdata, order book
#order format: msgtype, symbol, price, quantity, side, ordtype, orderID, time
#execution message format: orderID, Execstatus, symbol, quantity, avg price, side, time
#Execstatus can be the following: filled, replaced, cancelled, replacereject?, cancelreject
#order book format: orderID, time, symbol, price, quantity, side, ordtype
#trade matrix format: time, symbol, side, quantity, price, open/close, pnl
#position matrix: time, asset, #of shares, book value, market value,
global_tables = new.env()
global_tables$orderbook <- data.frame(matrix(0, 0, length(orderbook_spec)))
colnames(global_tables$orderbook) <- orderbook_spec
init_pos <- data.frame(matrix(0, 1, length(positionbook_spec)))
colnames(init_pos) <- positionbook_spec
init_pos[,Con_FieldName_Sym] = Con_Sym_Cash
init_pos[,c(Con_FieldName_Qty, Con_FieldName_BookVal, Con_FieldName_MktVal)] = init_cash
global_tables$positionbook <- list(init_pos)
names(global_tables$positionbook)[1] = 0
global_tables$tradesbook <- data.frame(matrix(0, 0, length(tradesbook_spec)))
colnames(global_tables$tradesbook) <- tradesbook_spec
global_tables$market_price <- list(vector())
global_tables$bid_price <- list(vector())
global_tables$ask_price <- list(vector())
data_extraction(global_tables, "market_price", "bid_price", "ask_price")
strategy_naive()
output <- output()
# yay
source('constants.r')
source('strategy_lib.r')
source('backtest_lib.r')
library(XLConnect)
library(knitr)
knitr::spin
opts_chunk$set(fig.path = 'figure/silk-')
init_cash = 100000
#global_variables: position matrices, trade matrices, ourdata, order book
#order format: msgtype, symbol, price, quantity, side, ordtype, orderID, time
#execution message format: orderID, Execstatus, symbol, quantity, avg price, side, time
#Execstatus can be the following: filled, replaced, cancelled, replacereject?, cancelreject
#order book format: orderID, time, symbol, price, quantity, side, ordtype
#trade matrix format: time, symbol, side, quantity, price, open/close, pnl
#position matrix: time, asset, #of shares, book value, market value,
global_tables = new.env()
global_tables$orderbook <- data.frame(matrix(0, 0, length(orderbook_spec)))
colnames(global_tables$orderbook) <- orderbook_spec
init_pos <- data.frame(matrix(0, 1, length(positionbook_spec)))
colnames(init_pos) <- positionbook_spec
init_pos[,Con_FieldName_Sym] = Con_Sym_Cash
init_pos[,c(Con_FieldName_Qty, Con_FieldName_BookVal, Con_FieldName_MktVal)] = init_cash
global_tables$positionbook <- list(init_pos)
names(global_tables$positionbook)[1] = 0
knitr::spin(main.r)
getwd()
library(XLConnect)
if(Sys.getenv("JAVA_HOME")!=""){
Sys.setenv(JAVA_HOME="")
}
library(rJava)
system("java -version")
library(XLConnect)
source('constants.r')
source('strategy_lib.r')
source('backtest_lib.r')
library(XLConnect)
library(knitr)
global_tables = new.env()
global_tables$orderbook <- data.frame(matrix(0, 0, length(orderbook_spec)))
colnames(global_tables$orderbook) <- orderbook_spec
init_pos <- data.frame(matrix(0, 1, length(positionbook_spec)))
colnames(init_pos) <- positionbook_spec
init_pos[,Con_FieldName_Sym] = Con_Sym_Cash
init_pos[,c(Con_FieldName_Qty, Con_FieldName_BookVal, Con_FieldName_MktVal)] = init_cash
global_tables$positionbook <- list(init_pos)
names(global_tables$positionbook)[1] = 0
global_tables$tradesbook <- data.frame(matrix(0, 0, length(tradesbook_spec)))
colnames(global_tables$tradesbook) <- tradesbook_spec
global_tables$market_price <- list(vector())
global_tables$bid_price <- list(vector())
global_tables$ask_price <- list(vector())
data_extraction(global_tables, "market_price", "bid_price", "ask_price")
tick_name
env[[tick_name]]
market_price
market_price
env[[tick_name]]
ask
