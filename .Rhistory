#Execstatus can be the following: filled, replaced, cancelled, replacereject?, cancelreject
#order book format: orderID, time, symbol, price, quantity, side, ordtype
#trade matrix format: time, symbol, side, quantity, price, open/close, pnl
#position matrix: time, asset, #of shares, book value, market value,
global_tables = new.env()
global_tables[[Con_GlobalVarName_LOB]]<- data.frame(matrix(0, 0, length(orderbook_spec)))
colnames(global_tables[[Con_GlobalVarName_LOB]]) <- orderbook_spec
#the position book is a list of data frames
init_pos <- data.frame(matrix(0, 1, length(positionbook_spec)))
colnames(init_pos) <- positionbook_spec
init_pos[,Con_FieldName_Sym] = Con_Sym_Cash
init_pos[,c(Con_FieldName_Qty, Con_FieldName_BookVal, Con_FieldName_MktVal)] = init_cash
global_tables[[Con_GlobalVarName_PositionBook]] <- list(init_pos)
names(global_tables[[Con_GlobalVarName_PositionBook]])[1] = 0
global_tables[[Con_GlobalVarName_TradesBook]] <- data.frame(matrix(0, 0, length(tradesbook_spec)))
colnames(global_tables[[Con_GlobalVarName_TradesBook]]) <- tradesbook_spec
global_tables[[Con_GlobalVarName_MktPrice]] <- list(vector())
global_tables[[Con_GlobalVarName_BidPrice]] <- list(vector())
global_tables[[Con_GlobalVarName_AskPrice]] <- list(vector())
data_extraction("AAPL.xls", global_tables, "AAPL", Con_GlobalVarName_MktPrice, Con_GlobalVarName_BidPrice, Con_GlobalVarName_AskPrice)
strategy_naive(global_tables[[Con_GlobalVarName_MktPrice]][["Date"]][1],
global_tables[[Con_GlobalVarName_MktPrice]][["Date"]][length(global_tables[[Con_GlobalVarName_MktPrice]][["Date"]])],
"AAPL", global_tables, bid= Con_GlobalVarName_BidPrice,
ask = Con_GlobalVarName_AskPrice,
mktprice = Con_GlobalVarName_MktPrice,
positionbook = Con_GlobalVarName_PositionBook,
pendingbook = Con_GlobalVarName_LOB)
# output <- function(tradesbook, positionbook, ask_prices, bid_prices, market_data){
### TESTED
tradesbook <- global_tables$tradesbook
# manually add a row into the tradebook since the naive strategy doesn't empty inventory at end of session
new_row <- c(1444071660, "AAPL", 1, 1, 110.92, "Close", .15)
tradesbook <- rbind(tradesbook, new_row)
positionbook <- global_tables$positionbook
### TESTED
### TESTED
# manipulate positionbook to make it a dataframe (it is received as a list)
positionbook <- do.call(rbind, positionbook)
positionbook <- cbind(Timestamp = rownames(positionbook), positionbook)
rownames(positionbook) <- 1:nrow(positionbook)
positionbook$Timestamp <- sapply(strsplit(as.character(positionbook$Timestamp),".",fixed = TRUE), "[[", 1)
ask_prices <- global_tables$ask_price
bid_prices <- global_tables$bid_price
### TESTED
### TESTED
# find the unique stocks that have been traded over the duration
stock_list <- unique(as.vector(tradesbook$Symbol))
# Set up the data frame which will store the cumulative pnl values for each stock and portfolio
Pnl_df <- data.frame(Symbol=character(), DateTime=as.Date(character()), BidAskPrice=character(),
BookValue=integer(), Side=integer(), Quantity = integer(),
Open.Close = character(), PnLStock = integer(), Cash = integer(),
Portfolio = integer(), PnLPortfolio = integer())
### TESTED
### TESTED
# loop through all the stocks that have been traded
for (i in 1:length(stock_list)){
stock_name <- stock_list[i]
# filter the tradesbook for only the selected stock
filtered_tradesbook <- subset(tradesbook, Symbol == stock_name)
# loop through all the trades made in the tradesbook
for (j in 1:nrow(filtered_tradesbook)){
curr_side <- filtered_tradesbook$Side[j]
curr_pos <- filtered_tradesbook$`Open/Close`[j]
start_time_date_unix <- as.character(filtered_tradesbook[j, "Timestamp"])
end_time_date_unix <- as.character(filtered_tradesbook[j + 1, "Timestamp"])
start_time_date <- as.POSIXct(as.numeric(filtered_tradesbook[j, "Timestamp"]), origin="1970-01-01")
end_time_date <- as.POSIXct(as.numeric(filtered_tradesbook[j + 1, "Timestamp"]), origin="1970-01-01")
book_value <- positionbook[positionbook$Timestamp == start_time_date_unix & positionbook$Symbol == stock_name, ]["BookValue"]
qty_owned <- positionbook[positionbook$Timestamp == start_time_date_unix & positionbook$Symbol == stock_name, ]["Quantity"]
if (curr_side == 1 && curr_pos == "Open"){
# add part in future if trading more than one stock, must access the correct market data
# depending on what the value of stock_name is
stock_matrix <- ask_prices
type <- "bid"
} else if (curr_side == 2 && curr_pos == "Open"){
stock_matrix <- bid_prices
type <- "ask"
} else if (curr_pos == "Close") {
next
}
for (i in 1:NROW(stock_matrix)){
if (stock_matrix[i, "Date"] > end_time_date) {
break
} else if (stock_matrix[i,"Date"] >= start_time_date){
# must clarify what price would we realize profits at (i.e what is market value at a given time)
# add part in future if trading more than one stock, must access the correct market data
# depending on what the value of stock_name is
if (type == "ask") {
bidask_price <- ask_prices[i, "LOW"]
} else {
bidask_price <- bid_prices[i, "HIGH"]
}
if (stock_matrix[i, "Date"] == end_time_date) {
curr_pos <- "Close"
if (curr_side == 1){
curr_side == 2
} else {
curr_side == 1
}
}
Pnl_df <- rbind(Pnl_df, data.frame(Symbol = stock_name, DateTime = stock_matrix[i, "Date"],
BidAskPrice = bidask_price,
BookValue = book_value, Side = curr_side,
Quantity = qty_owned, OpenClose = curr_pos))
}
}
}
}
### TESTED
### TESTED
# calculate the cumulative PnL of each stock
for (i in 1:NROW(Pnl_df)){
curr_symbol <- Pnl_df[i, "Symbol"]
prev_symbol <- Pnl_df[i-1, "Symbol"]
curr_side <- Pnl_df[i, "Side"]
# multiply the book value by -1 to obtain a posititve quantity
if (curr_side == 1){
curr_pnl <- (Pnl_df[i, "BidAskPrice"] - Pnl_df[i, "BookValue"])*Pnl_df[i, "Quantity"]
} else {
book_value <- Pnl_df[i, "BookValue"]*-1
short_qty <- Pnl_df[i, "Quantity"]*-1
curr_pnl <- (Pnl_df[i, "BidAskPrice"] - book_value*short_qty)*-1
}
# find cum. value. Ensure that the cumulative value is only carried from previous if it was the same stock
if (i == 1) {
Pnl_df[i, "PnLStock"] <- curr_pnl
} else {
if (curr_symbol == prev_symbol){
prev_pnl <- Pnl_df[i-1, "PnLStock"]
} else {
prev_pnl <- 0
}
Pnl_df[i, "PnLStock"] <- prev_pnl + curr_pnl
}
}
### TESTED
### TESTED
# order the Pnl data frame in order of date/time since it is sectioned by symbol
Pnl_df <- Pnl_df[order(Pnl_df$DateTime, decreasing = FALSE), ]
# record the cash in the account at each time step, pulling from the positionbook.
for (i in 1:NROW(Pnl_df)){
curr_date_time <- Pnl_df[i, "DateTime"]
# start for loop on second element since the first is at time 0 and records the default cash position
for (j in 2:NROW(positionbook)){
if (as.POSIXct(as.numeric(positionbook[j, "Timestamp"]), origin="1970-01-01") == curr_date_time && positionbook[j, "Symbol"] == "Cash"){
Pnl_df[i, "Cash"] <- positionbook[j, "BookValue"]
}
}
# if there is no datetime match in the positions matrix, this means that there was no position
# taken at the time and therefore cash is just equal to the previous time step (no change)
if (is.na(Pnl_df[i, "Cash"])){
Pnl_df[i, "Cash"] <- Pnl_df[i-1, "Cash"]
}
}
### TESTED
### TESTED
# find the unique times in which some stock was owned
time_list <- as.data.frame(unique(Pnl_df$DateTime))
# change name of column header
names(time_list)[1] <- "DateTime"
# calculate portfolio values at each unique time step
for (i in 1:NROW(time_list)){
filtered_times <- subset(Pnl_df, DateTime == time_list[i,1])
liquidated_positions <- 0
for (j in 1:NROW(filtered_times)){
liquidated_positions <- filtered_times[j, "BidAskPrice"]*(as.numeric(filtered_times[j, "Quantity"])) + liquidated_positions
if (j == NROW(filtered_times)){
# if (filtered_times[j, "Side"] == 1){
time_list[i, "PortfolioValue"] <- filtered_times[j, "Cash"] + liquidated_positions
# } else if(filtered_times[j, "Side"] == 2) {
# time_list[i, "PortfolioValue"] <- filtered_times[j, "Cash"] - liquidated_positions
# }
}
}
}
### TESTED
### TESTED
# calculate cumulative portfolio pnl at each time step
for (i in 1:NROW(time_list)){
if (i == 1){
prev_pnl <- 0
curr_pnl <- time_list[i, "PortfolioValue"] - init_cash
time_list[i, "PnLPortfolio"] <- prev_pnl + curr_pnl
} else {
prev_pnl <- time_list[i-1, "PnLPortfolio"]
curr_pnl <- time_list[i, "PortfolioValue"] - init_cash
time_list[i, "PnLPortfolio"] <-  prev_pnl + curr_pnl
}
}
View(time_list)
View(Pnl_df)
mxdrwdown <- maxDrawDown(time_list$PnLPortfolio)
mxdrwdown
mxdrwdown <- maxdrawdown(time_list$PnLPortfolio)
mxdrwdown
pnl <- time_list$PnLPortfolio
drawdown <- function(pnl) {
cum.pnl <- c(0, cumsum(pnl))
drawdown <- cum.pnl - cummax(cum.pnl)
return(tail(drawdown, -1))
}
mxdrwdown <- maxdrawdown(drawdown(pnl))
mxdrwdown
pnl <- time_list$PnLPortfolio
drawdown <- function(pnl) {
cum.pnl <- c(0, cumsum(pnl))
drawdown <- cum.pnl - cummax(cum.pnl)
return(tail(drawdown, -1))
}
drawdown(pnl)
drawdown <- function(pnl) {
cum.pnl <- time_list$PnLPortfolio
drawdown <- cum.pnl - cummax(cum.pnl)
return(tail(drawdown, -1))
}
drawdown(pnl)
cum.pnl
cum.pnl <- time_list$PnLPortfolio
cum.pnl
cummax(cum.pnl)
pnl <- c(12,10,5,-4,-2,1,5,6)
drawdown <- function(pnl) {
cum.pnl <- c(0, cumsum(pnl))
drawdown <- cum.pnl - cummax(cum.pnl)
return(tail(drawdown, -1))
}
drawdown(pnl)
drawdown <- function(pnl) {
cum.pnl <- c(0, time_list$PnLPortfolio)
drawdown <- cum.pnl - cummax(cum.pnl)
return(tail(drawdown, -1))
}
drawdown(pnl)
for (i in 1:NROW(time_list)){
if (i == 1){
prev_pnl <- 0
curr_pnl <- time_list[i, "PortfolioValue"] - init_cash
time_list[i, "PnLPortfolio"] <- curr_pnl
time_list[i, "CumPnLPortfolio"] <- prev_pnl + curr_pnl
} else {
prev_pnl <- time_list[i-1, "PnLPortfolio"]
curr_pnl <- time_list[i, "PortfolioValue"] - init_cash
time_list[i, "PnLPortfolio"] <- curr_pnl
time_list[i, "CumPnLPortfolio"] <-  prev_pnl + curr_pnl
}
}
### TESTED
# find the unique times in which some stock was owned
time_list <- as.data.frame(unique(Pnl_df$DateTime))
# change name of column header
names(time_list)[1] <- "DateTime"
# calculate portfolio values at each unique time step
for (i in 1:NROW(time_list)){
filtered_times <- subset(Pnl_df, DateTime == time_list[i,1])
liquidated_positions <- 0
for (j in 1:NROW(filtered_times)){
liquidated_positions <- filtered_times[j, "BidAskPrice"]*(as.numeric(filtered_times[j, "Quantity"])) + liquidated_positions
if (j == NROW(filtered_times)){
# if (filtered_times[j, "Side"] == 1){
time_list[i, "PortfolioValue"] <- filtered_times[j, "Cash"] + liquidated_positions
# } else if(filtered_times[j, "Side"] == 2) {
# time_list[i, "PortfolioValue"] <- filtered_times[j, "Cash"] - liquidated_positions
# }
}
}
}
for (i in 1:NROW(time_list)){
curr_pnl <- time_list[i, "PortfolioValue"] - init_cash
time_list[i, "PnLPortfolio"] <- curr_pnl
}
time_list[i, "CumPortfolioValue"] <- cumsum(c(0, time_list[i, "PnLPortfolio"]))
dt <- c(0, time_list[i, "PnLPortfolio"])
time_list[i, "CumPortfolioValue"] <- cumsum(dt)
dt <- c(0, time_list[, "PnLPortfolio"])
dt
time_list[i, "CumPortfolioValue"] <- cumsum(dt)
time_list[, "CumPortfolioValue"] <- cumsum(dt)
time_list[, "CumPortfolioValue"] <- cumsum(time_list[, "PnLPortfolio"])
for (i in 1:NROW(time_list)){
curr_pnl <- time_list[i, "PortfolioValue"] - init_cash
time_list[i, "PnLPortfolio"] <- curr_pnl
}
dt <- c(0, time_list[, "PnLPortfolio"])
time_list[, "CumPnLPortfolio"] <- cumsum(time_list[, "PnLPortfolio"])
### TESTED
# find the unique times in which some stock was owned
time_list <- as.data.frame(unique(Pnl_df$DateTime))
# change name of column header
names(time_list)[1] <- "DateTime"
# calculate portfolio values at each unique time step
for (i in 1:NROW(time_list)){
filtered_times <- subset(Pnl_df, DateTime == time_list[i,1])
liquidated_positions <- 0
for (j in 1:NROW(filtered_times)){
liquidated_positions <- filtered_times[j, "BidAskPrice"]*(as.numeric(filtered_times[j, "Quantity"])) + liquidated_positions
if (j == NROW(filtered_times)){
# if (filtered_times[j, "Side"] == 1){
time_list[i, "PortfolioValue"] <- filtered_times[j, "Cash"] + liquidated_positions
# } else if(filtered_times[j, "Side"] == 2) {
# time_list[i, "PortfolioValue"] <- filtered_times[j, "Cash"] - liquidated_positions
# }
}
}
}
### TESTED
### TESTED
# calculate cumulative portfolio pnl at each time step
for (i in 1:NROW(time_list)){
curr_pnl <- time_list[i, "PortfolioValue"] - init_cash
time_list[i, "PnLPortfolio"] <- curr_pnl
}
dt <- c(0, time_list[, "PnLPortfolio"])
time_list[, "CumPnLPortfolio"] <- cumsum(time_list[, "PnLPortfolio"])
library(fTrading)
mxdrwdown <- maxDrawDown(time_list$CumPnLPortfolio)
mxdrwdown
class(time_list$CumPnLPortfolio)
library(tseries)
mxdrwdown <- maxdrawdown(time_list$PnLPortfolio)
mxdrwdown
mxdrwdown <- maxdrawdown(time_list$CumPnLPortfolio)
mxdrwdown
mxdrwdown <- maxdrawdown(time_list$PortfolioValue)
mxdrwdown
mxdrwdown <- 0
mxdrwdown <- maxdrawdown(time_list$PortfolioValue)
mxdrwdown
mxdrwdown <- 0
library(fTrading)
mxdrwdown <- maxDrawDown(time_list$PortfolioValue)
mxdrwdown
test <- c(500,750,400,600,350,800)
mxdrwdown <- maxDrawDown(test)
mxdrwdown
library(tseries)
mxdrwdown <- maxdrawdown(time_list$PortfolioValue)
mxdrwdown
MDD_peak <- max(MDD_from, MDD_peak)
library(tseries)
mxdrwdown <- maxdrawdown(time_list$PortfolioValue)
MDD <- mxdrwdown$maxdrawdown
MDD_from <- mxdrwdown$from
MDD_to <- mxdrwdown$to
MDD_peak <- max(MDD_from, MDD_peak)
MDD_peak <- max(c(MDD_from, MDD_peak))
MDD_peak <- max(c(MDD_from, MDD_to))
library(tseries)
mxdrwdown <- maxdrawdown(time_list$PortfolioValue)
MDD <- mxdrwdown$maxdrawdown
MDD_from <- mxdrwdown$from
MDD_to <- mxdrwdown$to
MDD_peak <- max(c(MDD_from, MDD_to))
MDD_trough <- min(c(MDD_from, MDD_to))
MDD_from
mxdrwdown
MDD_from <- time_list[mxdrwdown$from, "PortfolioValue"]
MDD_from
MDD_from <- time_list[mxdrwdown$from, "PortfolioValue"]
MDD_to <- time_list[mxdrwdown$to, "PortfolioValue"]
MDD_peak <- max(c(MDD_from, MDD_to))
MDD_trough <- min(c(MDD_from, MDD_to))
MDD_perc <- (MDD_trough - MDD_peak)/(MDD_peak)
MDD_perc
MDD_perc <- (MDD_trough - MDD_peak)/(MDD_peak)*100
MDD_perc
MDD_trough
MDD_peak
MDD_period <- c(time_list[mxdrwdown$from, "DateTime"], time_list[mxdrwdown$to, "DateTime"])
MDD_period
end_cash <- Pnl_df[NROW(Pnl_df), "Cash"]
return1 <- ((end_cash - init_cash)/(init_cash))*100
return1
# output <- function(tradesbook, positionbook, ask_prices, bid_prices, market_data){
# note to edit portfolio values for shorts
# since I don't have access to the real dataframes, I created them manually
tradesbook <- read.csv("tradesbook.csv", header = TRUE)
positionbook <- read.csv("positionbook.csv", header = TRUE)
# tradesbook <- global_tables$tradesbook
# positionbook <- global_tables$positionbook
# the following are created because the file that data_extraction pulls only carries
# one day's worth of data and I need multiple days. These variables are for testing
# purposes only
ask_prices <- read.csv("ask_AAPL.csv", header = TRUE)
bid_prices <- read.csv("bid_AAPL.csv", header = TRUE)
# ask_prices <- global_tables$ask_price
# bid_prices <- global_tables$bid_price
# convert to date formats
tradesbook$Timestamp <- as.POSIXct(tradesbook$Timestamp)
positionbook$Timestamp <- as.POSIXct(positionbook$Timestamp)
ask_prices$Date <- as.POSIXct(ask_prices$Date)
bid_prices$Date <- as.POSIXct(bid_prices$Date)
# find the unique stocks that have been traded over the duration
stock_list <- unique(as.vector(tradesbook$Symbol))
# Set up the data frame which will store the cumulative pnl values for each stock and portfolio
Pnl_df <- data.frame(Symbol=character(), DateTime=as.Date(character()), BidAskPrice=character(),
BookValue=integer(), Side=integer(), QuantityOwned = integer(),
Open.Close = character(), PnLStock = integer(), Cash = integer(),
Portfolio = integer(), PnLPortfolio = integer())
# loop through all the stocks that have been traded
for (i in 1:length(stock_list)){
stock_name <- stock_list[i]
filtered_position <- subset(positionbook, Symbol == stock_name)
filtered_trades <- subset(tradesbook, Symbol == stock_name)
# 1. filter the position and trades table and 2. merge the two because data will be needed
# from both tables
position_trades <- cbind(filtered_position, filtered_trades)
for (j in 1:NROW(position_trades)){
curr_side <- position_trades[j, "Side"]
curr_pos <- position_trades[j, "Open.Close"]
book_value <- position_trades[j, "BookValue"]
start_time_date <- position_trades[j, "Timestamp"]
end_time_date <- position_trades[j + 1, "Timestamp"]
qty_owned <- position_trades[j, "Quantity.Owned"]
# check if there is quantity of stock owned, if there is then go to the ask/bid price
# data frames to access the market values for each time period
if (qty_owned > 0){
if ((curr_side == 1 && curr_pos == "Open") || (curr_side == 1 && curr_pos == "Close")){
# add part in future if trading more than one stock, must access the correct market data
# depending on what the value of stock_name is
# This should be used in real scenarios stock_matrix <- global_tables$ask_price
stock_matrix <- ask_prices
type <- "bid"
} else if ((curr_side == -1 && curr_pos == "Open") || (curr_side == -1 && curr_pos == "Close")){
# This should be used in real scenarios stock_matrix <- global_tables$bid_price
stock_matrix <- bid_prices
type <- "ask"
}
for (i in 1:NROW(stock_matrix)){
if (stock_matrix[i, "Date"] == end_time_date) {
break
} else if (stock_matrix[i,"Date"] >= start_time_date){
# must clarify what price would we realize profits at (i.e what is market value at a given time)
if (type == "ask") {
bidask_price <- stock_matrix[i, "LOW"]
} else {
bidask_price <- stock_matrix[i, "HIGH"]
}
Pnl_df <- rbind(Pnl_df, data.frame(Symbol = stock_name, DateTime = stock_matrix[i, "Date"],
BidAskPrice = bidask_price,
BookValue = book_value, Side = curr_side,
Quantity = qty_owned, OpenClose = curr_pos))
}
}
} else {
next
}
}
}
# calculate the cumulative PnL of each stock
for (i in 1:NROW(Pnl_df)){
curr_symbol <- Pnl_df[i, "Symbol"]
prev_symbol <- Pnl_df[i-1, "Symbol"]
curr_pnl <- (((Pnl_df[i, "BidAskPrice"]-Pnl_df[i, "BookValue"]) / (Pnl_df[i, "BookValue"]))) * 100
if (i ==1) {
Pnl_df[i, "PnLStock"] <- curr_pnl
} else {
if (curr_symbol == prev_symbol){
prev_pnl <- Pnl_df[i-1, "PnLStock"]
} else {
prev_pnl <- 0
}
Pnl_df[i, "PnLStock"] <- prev_pnl + curr_pnl
}
}
# order the Pnl data frame in order of date/time since it is sectioned by symbol
Pnl_df <- Pnl_df[order(Pnl_df$DateTime, decreasing = FALSE), ]
# record the cash in the account at each time step, pulling from the positionbook.
for (i in 1:NROW(Pnl_df)){
curr_date_time <- Pnl_df[i, "DateTime"]
for (j in 2:NROW(positionbook)){
if (positionbook[j, "Timestamp"] == curr_date_time && positionbook[j, "Symbol"] == "Cash"){
Pnl_df[i, "Cash"] <- positionbook[j, "BookValue"]
}
}
# if there is no datetime match in the positions matrix, this means that there was no position
# taken at the time and therefore cash is just equal to the previous time step (no change)
if (is.na(Pnl_df[i, "Cash"])){
Pnl_df[i, "Cash"] <- Pnl_df[i-1, "Cash"]
}
}
tradesbook
positionbook
filter_pnL <- subset(tradesbook, Symbol == "AAPL")
filter_pnl
filter_pnL
### TESTED
tradesbook <- global_tables$tradesbook
# manually add a row into the tradebook since the naive strategy doesn't empty inventory at end of session
new_row <- c(1444071660, "AAPL", 1, 1, 110.92, "Close", .15)
tradesbook <- rbind(tradesbook, new_row)
positionbook <- global_tables$positionbook
### TESTED
filter_pnL <- subset(tradesbook, Symbol == "AAPL")
filter_pnL
positionbook <- read.csv("positionbook.csv", header = TRUE)
filter_pnL <- subset(positionbook, Symbol == "AAPL")
filter_pnL
tradesbook <- read.csv("tradesbook.csv", header = TRUE)
filter_pnL <- subset(tradesbook, Symbol == "AAPL")
filter_pnL
positionbook <- global_tables$positionbook
positionbook
positionbook <- do.call(rbind, positionbook)
positionbook <- cbind(Timestamp = rownames(positionbook), positionbook)
rownames(positionbook) <- 1:nrow(positionbook)
positionbook$Timestamp <- sapply(strsplit(as.character(positionbook$Timestamp),".",fixed = TRUE), "[[", 1)
positionbook
tradesbook <- global_tables$tradesbook
# manually add a row into the tradebook since the naive strategy doesn't empty inventory at end of session
new_row <- c(1444071660, "AAPL", 1, 1, 110.92, "Close", .15)
tradesbook <- rbind(tradesbook, new_row)
tradesbook
