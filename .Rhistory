orderline[entry, Con_FieldName_Qty] <- abs(tradequant)
if (tradequant > 0){
orderline[entry, Con_FieldName_Side] <- Con_Side_Buy
orderline[entry, Con_FieldName_Price] <- tick_data[a+30,"LOW"]
} else{
orderline[entry, Con_FieldName_Side] <- Con_Side_Sell
orderline[entry, Con_FieldName_Price] <- tick_data[a+30,"HIGH"]
}
orderline[entry, Con_FieldName_OrdType] <- Con_OrdType_Mkt
orderline[entry, Con_FieldName_Time] <- as.POSIXct((as.numeric(next_date+60)),origin = "1970-01-01")
response <- handle_orders(orderline, stock, global_tables, tick_data[a+29, "Date"])
print(response)
}
}
}
a <- a + 30
}
# constants
jump <- 13
return_and_stdev <- function(prices){
for (i in 2:NROW(prices)){
prices[i, "Return"] <- log10(prices[i,"Price"]/prices[i-1,"Price"])
}
final_return <- mean(na.omit(prices[, "Return"]))
for (i in 2:NROW(prices)){
prices[i, "StDev"] <- (prices[i, "Return"]-final_return)^2
}
final_stdev <- sum(na.omit(prices[, "StDev"]))/(NROW(prices)-1)
return(list(return=final_return, stdev=final_stdev))
}
IPR_df <- data.frame(Date = as.character(), Symbol = as.character(), IPR = as.integer())
# Stocks <- c("AC", "BNS", "BMO")
Stocks <- c("AC")
EquityList <- c("tick", "ask", "bid")
a <- 1
# only trading every 30 minutes, change this value when trading time is different
end_a <- nrow(env[["list_dates"]])*12*30*length(Stocks)
end_a <- 99
# loop through each minute (a) but only calculate IPR every 30 minutes
while (a < end_a){
print(a)
for (stock in Stocks){
stock_data <- paste(stock,EquityList[1],sep="_")
tick_data <- env[[stock_data]]
if (strftime(tick_data[a, "Date"], format="%H:%M:%S") == "15:30:00"){
a <- a + 1
break
}
next_date <- tick_data[a+29, "Date"]
P_asterix <- tick_data[a+29, "LAST_PRICE"]
P_asterix_j_date <-  tick_data[(a+29) - jump, "LAST_PRICE"]
start_row <- 1
end_row <- which(tick_data$Date == next_date)
price_estimates <- data.frame(Price = tick_data[start_row:end_row, "LAST_PRICE"])
ret <- return_and_stdev(price_estimates)$return
stdev <- return_and_stdev(price_estimates)$stdev
z <- (log(P_asterix/P_asterix_j_date) - jump * ret) / (sqrt(jump * stdev))
IPR <- pnorm(z)
IPR_df <- rbind(IPR_df, data.frame(Date = next_date + 60, Symbol = stock, IPR = IPR))
if (stock == Stocks[length(Stocks)]){
temp_dframe <- subset(IPR_df, Date == "2015-05-13 10:00:00")
temp_dframe$Symbol <- as.character(temp_dframe$Symbol)
# order the dataframe based on IPR values
temp_dframe <- temp_dframe[order(temp_dframe$IPR),]
# create buy or sell orders
# Access positionbook, find current stock position and current value
# Sum up all values to get total portfolio value
if (a + 29 == 30){
currposition <- global_tables$positionbook[["0"]]
} else {
currposition <- global_tables[["positionbook"]][[length(global_tables[["positionbook"]])]]
}
totalvalue <- 0
if (nrow(currposition) == 1){
totalvalue <- currposition$MarketValue[1]
} else {
for (s in 2:nrow(currposition)){
stock = currposition$Symbol[s]
stock_data <- paste(stock,EquityList[1],sep="_")
tick_data <- env[[stock_data]]
totalvalue <- currposition$MarketValue[1]
totalvalue <- totalvalue + currposition$Quantity[s]*tick_data[which(tick_data$Date == (next_date+60)),"Date"]
}
}
ordercounter <- 1
orderline = data.frame(matrix(NA, 0, length(order_msg_spec)))
colnames(orderline) <- order_msg_spec
for (b in 1:length(temp_dframe)){
stock = as.character(temp_dframe$Symbol[b])
stock_data <- paste(stock,EquityList[1],sep="_")
tick_data <- env[[stock_data]]
# assign percentages to each stock for cash allocations
cash_alloc <- -(temp_dframe[b, "IPR"]) + 0.5
# send an order to the market with sell and using the existing cash * appropriate Pct
# Calculate dollar value based on percentage cash_alloc * totalvalue
allocvalue <- cash_alloc*totalvalue
# Divide cashalloc*totalvalue by share price to obtain # of shares
futurequant<- floor(allocvalue/tick_data[a+30,"LAST_PRICE"])
# Subtract future # of shares with current number of shares
pastquant = 0
if (sum(currposition$Symbol == stock) == 0){
pastquant = 0
} else {
pastquant = currposition[which(currposition$Symbol == stock),"Quantity"]
}
tradequant <- futurequant - pastquant
# Send appropriate order
entry <- nrow(orderline) + 1
orderline[entry, Con_FieldName_MsgType] <- Con_MsgType_New
orderline[entry, Con_FieldName_OrdID] <- ordercounter
ordercounter <- ordercounter + 1
orderline[entry, Con_FieldName_Sym] <- temp_dframe$Symbol[b]
orderline[entry, Con_FieldName_Qty] <- abs(tradequant)
if (tradequant > 0){
orderline[entry, Con_FieldName_Side] <- Con_Side_Buy
orderline[entry, Con_FieldName_Price] <- tick_data[a+30,"LOW"]
} else{
orderline[entry, Con_FieldName_Side] <- Con_Side_Sell
orderline[entry, Con_FieldName_Price] <- tick_data[a+30,"HIGH"]
}
orderline[entry, Con_FieldName_OrdType] <- Con_OrdType_Mkt
orderline[entry, Con_FieldName_Time] <- as.POSIXct((as.numeric(next_date+60)),origin = "1970-01-01")
response <- handle_orders(orderline, stock, global_tables, tick_data[a+29, "Date"])
print(response)
}
}
}
a <- a + 30
}
sum(currposition$Symbol == stock)
currposition$Symbol
global_tables$positionbook
init_cash = 100000
#global_variables: position matrices, trade matrices, ourdata, order book
>>>>>>> origin/master
#order format: msgtype, symbol, price, quantity, side, ordtype, orderID, time
#execution message format: orderID, Execstatus, symbol, quantity, avg price, side, time
#Execstatus can be the following: filled, replaced, cancelled, replacereject?, cancelreject
#order book format: orderID, time, symbol, price, quantity, side, ordtype
#trade matrix format: time, symbol, side, quantity, price, open/close, pnl
<<<<<<< HEAD
#position matrix: time, asset(symbol), #of shares, book value, market value,
Con_FieldName_MsgType = "Msgtype"
Con_FieldName_Sym = "Symbol"
Con_FieldName_Price = "Price"
Con_FieldName_Qty = "Quantity"
Con_FieldName_Side = "Side"
Con_FieldName_OrdType = "OrdType"
Con_FieldName_OrdID = "OrdID"
Con_FieldName_Time = "Timestamp"
Con_FieldName_ExecStatus = "ExecStatus"
Con_FieldName_AvgPrice = "AvgPrice"
Con_FieldName_BookVal = "BookValue"
Con_FieldName_MktVal = "MarketValue"
Con_FieldName_OpenClose = "Open/Close"
Con_FieldName_Pnl = "PnL"
<<<<<<< HEAD
=======
Con_FieldName_CurrentBid = "CurrentBid"
Con_FieldName_CurrentAsk = "CurrentAsk"
Con_FieldName_CurrentTick = "CurrentTick"
Con_FieldName_LastHighestBid = "HighestBid"
Con_FieldName_LastLowestAsk = "LowestAsk"
Con_Data_ColName_LastNumTicks = "NumTicks"
Con_Data_ColName_LastVolume = "Volume"
Con_Data_ColName_LastValue = "Value"
>>>>>>> origin/master
Con_ExecStatus_filled <- 2
Con_Side_Buy <- 1
Con_Side_Sell <- 2
Con_MsgType_New <- "D"
Con_MsgType_Replace <- "G"
Con_MsgType_Cancel <- "F"
Con_OrdType_Mkt <- 1
Con_OrdType_Limit <- 2
Con_Sym_Cash <- "Cash"
Con_Sym_Portfolio<- "Portfolio"
Con_OpenClose_Open <- "Open"
Con_OpenClose_Close <- "Close"
Con_PriceCol <- 2
Con_GlobalVarName_LOB <- "PendingOrderBook"
Con_GlobalVarName_PositionBook <- "positionbook"
Con_GlobalVarName_TradesBook <- "tradesbook"
Con_GlobalVarName_MktPrice <- "market_price"
Con_GlobalVarName_BidPrice <- "bid_price"
Con_GlobalVarName_AskPrice <- "ask_price"
<<<<<<< HEAD
=======
Con_Data_Tick_Suffix <- "_tick"
Con_Data_Ask_Suffix <- "_ask"
Con_Data_Bid_Suffix <- "_bid"
Con_Data_ColName_Date <- "Date"
Con_Data_ColName_Open <- "OPEN"
Con_Data_ColName_High <- "HIGH"
Con_Data_ColName_Low <- "LOW"
Con_Data_ColName_LastPrice <- "LAST_PRICE"
Con_Data_ColName_NumTicks <- "NUMBER_TICKS"
Con_Data_ColName_Volume <- "VOLUME"
Con_Data_ColName_Value <- "VALUE"
>>>>>>> origin/master
order_msg_spec <- c(Con_FieldName_MsgType,
Con_FieldName_Sym,
Con_FieldName_Price,
Con_FieldName_Qty,
Con_FieldName_Side,
Con_FieldName_OrdType,
Con_FieldName_OrdID,
Con_FieldName_Time)
exec_msg_spec <- c(Con_FieldName_OrdID,
Con_FieldName_ExecStatus,
Con_FieldName_Sym,
Con_FieldName_Qty,
Con_FieldName_AvgPrice,
Con_FieldName_Side,
Con_FieldName_Time)
orderbook_spec <- c(Con_FieldName_OrdID,
Con_FieldName_Time,
Con_FieldName_Sym,
Con_FieldName_Price,
Con_FieldName_Qty,
Con_FieldName_Side,
Con_FieldName_OrdType)
positionbook_spec <- c(Con_FieldName_Sym,
Con_FieldName_Qty,
Con_FieldName_BookVal,
Con_FieldName_MktVal)
tradesbook_spec <- c(Con_FieldName_Time,
Con_FieldName_Sym,
Con_FieldName_Side,
Con_FieldName_Qty,
Con_FieldName_Price,
Con_FieldName_OpenClose,
Con_FieldName_Pnl)
<<<<<<< HEAD
=======
mkt_quote_spec <- c(Con_FieldName_Sym,
Con_FieldName_CurrentBid,
Con_FieldName_CurrentAsk,
Con_FieldName_CurrentTick,
Con_FieldName_LastHighestBid,
Con_FieldName_LastLowestAsk,
Con_Data_ColName_LastNumTicks,
Con_Data_ColName_LastVolume,
Con_Data_ColName_LastValue)
>>>>>>> origin/master
<<<<<<< HEAD
env <- global_tables
symbol <- "BNS"
time <- "2015-05-14 09:41:01 EDT"
getquotes(env,symbol,time)
source('strategy_hmm.r')
source('constants.r')
source('strategy_hmm.r')
env <- global_tables
symbol <- "BNS"
time <- "2015-05-14 09:41:01 EDT"
getquotes(env,symbol,time)
=======
#position matrix: time, asset, #of shares, book value, market value,
datafile_name = "../data/TSXdatafile.xls"
global_tables = new.env()
global_tables[[Con_GlobalVarName_LOB]]<- data.frame(matrix(0, 0, length(orderbook_spec)))
colnames(global_tables[[Con_GlobalVarName_LOB]]) <- orderbook_spec
#the position book is a list of data frames
init_pos <- data.frame(matrix(0, 1, length(positionbook_spec)))
colnames(init_pos) <- positionbook_spec
init_pos[,Con_FieldName_Sym] = Con_Sym_Cash
init_pos[,c(Con_FieldName_Qty, Con_FieldName_BookVal, Con_FieldName_MktVal)] = init_cash
global_tables[[Con_GlobalVarName_PositionBook]] <- list(init_pos)
names(global_tables[[Con_GlobalVarName_PositionBook]])[1] = 0
global_tables[[Con_GlobalVarName_TradesBook]] <- data.frame(matrix(0, 0, length(tradesbook_spec)))
colnames(global_tables[[Con_GlobalVarName_TradesBook]]) <- tradesbook_spec
global_tables[[Con_GlobalVarName_MktPrice]] <- list(vector())
global_tables[[Con_GlobalVarName_BidPrice]] <- list(vector())
global_tables[[Con_GlobalVarName_AskPrice]] <- list(vector())
global_tables[[Con_GlobalVarName_ListDates]] <- list(vector())
global_tables$positionbook
# constants
jump <- 13
return_and_stdev <- function(prices){
for (i in 2:NROW(prices)){
prices[i, "Return"] <- log10(prices[i,"Price"]/prices[i-1,"Price"])
}
final_return <- mean(na.omit(prices[, "Return"]))
for (i in 2:NROW(prices)){
prices[i, "StDev"] <- (prices[i, "Return"]-final_return)^2
}
final_stdev <- sum(na.omit(prices[, "StDev"]))/(NROW(prices)-1)
return(list(return=final_return, stdev=final_stdev))
}
IPR_df <- data.frame(Date = as.character(), Symbol = as.character(), IPR = as.integer())
# Stocks <- c("AC", "BNS", "BMO")
Stocks <- c("AC")
EquityList <- c("tick", "ask", "bid")
a <- 1
# only trading every 30 minutes, change this value when trading time is different
end_a <- nrow(env[["list_dates"]])*12*30*length(Stocks)
end_a <- 99
# loop through each minute (a) but only calculate IPR every 30 minutes
while (a < end_a){
print(a)
for (stock in Stocks){
stock_data <- paste(stock,EquityList[1],sep="_")
tick_data <- env[[stock_data]]
if (strftime(tick_data[a, "Date"], format="%H:%M:%S") == "15:30:00"){
a <- a + 1
break
}
next_date <- tick_data[a+29, "Date"]
P_asterix <- tick_data[a+29, "LAST_PRICE"]
P_asterix_j_date <-  tick_data[(a+29) - jump, "LAST_PRICE"]
start_row <- 1
end_row <- which(tick_data$Date == next_date)
price_estimates <- data.frame(Price = tick_data[start_row:end_row, "LAST_PRICE"])
ret <- return_and_stdev(price_estimates)$return
stdev <- return_and_stdev(price_estimates)$stdev
z <- (log(P_asterix/P_asterix_j_date) - jump * ret) / (sqrt(jump * stdev))
IPR <- pnorm(z)
IPR_df <- rbind(IPR_df, data.frame(Date = next_date + 60, Symbol = stock, IPR = IPR))
if (stock == Stocks[length(Stocks)]){
temp_dframe <- subset(IPR_df, Date == "2015-05-13 10:00:00")
temp_dframe$Symbol <- as.character(temp_dframe$Symbol)
# order the dataframe based on IPR values
temp_dframe <- temp_dframe[order(temp_dframe$IPR),]
# create buy or sell orders
# Access positionbook, find current stock position and current value
# Sum up all values to get total portfolio value
if (a + 29 == 30){
currposition <- global_tables$positionbook[["0"]]
} else {
currposition <- global_tables[["positionbook"]][[length(global_tables[["positionbook"]])]]
}
totalvalue <- 0
if (nrow(currposition) == 1){
totalvalue <- currposition$MarketValue[1]
} else {
for (s in 2:nrow(currposition)){
stock = currposition$Symbol[s]
stock_data <- paste(stock,EquityList[1],sep="_")
tick_data <- env[[stock_data]]
totalvalue <- currposition$MarketValue[1]
totalvalue <- totalvalue + currposition$Quantity[s]*tick_data[which(tick_data$Date == (next_date+60)),"Date"]
}
}
ordercounter <- 1
orderline = data.frame(matrix(NA, 0, length(order_msg_spec)))
colnames(orderline) <- order_msg_spec
for (b in 1:length(temp_dframe)){
stock = as.character(temp_dframe$Symbol[b])
stock_data <- paste(stock,EquityList[1],sep="_")
tick_data <- env[[stock_data]]
# assign percentages to each stock for cash allocations
cash_alloc <- -(temp_dframe[b, "IPR"]) + 0.5
# send an order to the market with sell and using the existing cash * appropriate Pct
# Calculate dollar value based on percentage cash_alloc * totalvalue
allocvalue <- cash_alloc*totalvalue
# Divide cashalloc*totalvalue by share price to obtain # of shares
futurequant<- floor(allocvalue/tick_data[a+30,"LAST_PRICE"])
# Subtract future # of shares with current number of shares
pastquant = 0
if (sum(currposition$Symbol == stock) == 0){
pastquant = 0
} else {
pastquant = currposition[which(currposition$Symbol == stock),"Quantity"]
}
tradequant <- futurequant - pastquant
# Send appropriate order
entry <- nrow(orderline) + 1
orderline[entry, Con_FieldName_MsgType] <- Con_MsgType_New
orderline[entry, Con_FieldName_OrdID] <- ordercounter
ordercounter <- ordercounter + 1
orderline[entry, Con_FieldName_Sym] <- temp_dframe$Symbol[b]
orderline[entry, Con_FieldName_Qty] <- abs(tradequant)
if (tradequant > 0){
orderline[entry, Con_FieldName_Side] <- Con_Side_Buy
orderline[entry, Con_FieldName_Price] <- tick_data[a+30,"LOW"]
} else{
orderline[entry, Con_FieldName_Side] <- Con_Side_Sell
orderline[entry, Con_FieldName_Price] <- tick_data[a+30,"HIGH"]
}
orderline[entry, Con_FieldName_OrdType] <- Con_OrdType_Mkt
orderline[entry, Con_FieldName_Time] <- as.POSIXct((as.numeric(next_date+60)),origin = "1970-01-01")
response <- handle_orders(orderline, stock, global_tables, tick_data[a+29, "Date"])
print(response)
}
}
}
a <- a + 30
}
head(global_tables[["AC_tick"]])
head(global_tables[["BNS_tick"]])
env[["AC_ask"]]
# constants
jump <- 13
return_and_stdev <- function(prices){
for (i in 2:NROW(prices)){
prices[i, "Return"] <- log10(prices[i,"Price"]/prices[i-1,"Price"])
}
final_return <- mean(na.omit(prices[, "Return"]))
for (i in 2:NROW(prices)){
prices[i, "StDev"] <- (prices[i, "Return"]-final_return)^2
}
final_stdev <- sum(na.omit(prices[, "StDev"]))/(NROW(prices)-1)
return(list(return=final_return, stdev=final_stdev))
}
IPR_df <- data.frame(Date = as.character(), Symbol = as.character(), IPR = as.integer())
# Stocks <- c("AC", "BNS", "BMO")
Stocks <- c("AC")
EquityList <- c("tick", "ask", "bid")
a <- 1
# only trading every 30 minutes, change this value when trading time is different
end_a <- nrow(env[["list_dates"]])*12*30*length(Stocks)
end_a <- 99
# loop through each minute (a) but only calculate IPR every 30 minutes
while (a < end_a){
print(a)
for (stock in Stocks){
stock_data <- paste(stock,EquityList[1],sep="_")
tick_data <- env[[stock_data]]
if (strftime(tick_data[a, "Date"], format="%H:%M:%S") == "15:30:00"){
a <- a + 1
break
}
next_date <- tick_data[a+29, "Date"]
P_asterix <- tick_data[a+29, "LAST_PRICE"]
P_asterix_j_date <-  tick_data[(a+29) - jump, "LAST_PRICE"]
start_row <- 1
end_row <- which(tick_data$Date == next_date)
price_estimates <- data.frame(Price = tick_data[start_row:end_row, "LAST_PRICE"])
ret <- return_and_stdev(price_estimates)$return
stdev <- return_and_stdev(price_estimates)$stdev
z <- (log(P_asterix/P_asterix_j_date) - jump * ret) / (sqrt(jump * stdev))
IPR <- pnorm(z)
IPR_df <- rbind(IPR_df, data.frame(Date = next_date + 60, Symbol = stock, IPR = IPR))
if (stock == Stocks[length(Stocks)]){
temp_dframe <- subset(IPR_df, Date == "2015-05-13 10:00:00")
temp_dframe$Symbol <- as.character(temp_dframe$Symbol)
# order the dataframe based on IPR values
temp_dframe <- temp_dframe[order(temp_dframe$IPR),]
# create buy or sell orders
# Access positionbook, find current stock position and current value
# Sum up all values to get total portfolio value
if (a + 29 == 30){
currposition <- global_tables$positionbook[["0"]]
} else {
currposition <- global_tables[["positionbook"]][[length(global_tables[["positionbook"]])]]
}
totalvalue <- 0
if (nrow(currposition) == 1){
totalvalue <- currposition$MarketValue[1]
} else {
for (s in 2:nrow(currposition)){
stock = currposition$Symbol[s]
stock_data <- paste(stock,EquityList[1],sep="_")
tick_data <- env[[stock_data]]
totalvalue <- currposition$MarketValue[1]
totalvalue <- totalvalue + currposition$Quantity[s]*tick_data[which(tick_data$Date == (next_date+60)),"Date"]
}
}
ordercounter <- 1
orderline = data.frame(matrix(NA, 0, length(order_msg_spec)))
colnames(orderline) <- order_msg_spec
for (b in 1:length(temp_dframe)){
stock = as.character(temp_dframe$Symbol[b])
stock_data <- paste(stock,EquityList[1],sep="_")
tick_data <- env[[stock_data]]
# assign percentages to each stock for cash allocations
cash_alloc <- -(temp_dframe[b, "IPR"]) + 0.5
# send an order to the market with sell and using the existing cash * appropriate Pct
# Calculate dollar value based on percentage cash_alloc * totalvalue
allocvalue <- cash_alloc*totalvalue
# Divide cashalloc*totalvalue by share price to obtain # of shares
futurequant<- floor(allocvalue/tick_data[a+30,"LAST_PRICE"])
# Subtract future # of shares with current number of shares
pastquant = 0
if (sum(currposition$Symbol == stock) == 0){
pastquant = 0
} else {
pastquant = currposition[which(currposition$Symbol == stock),"Quantity"]
}
tradequant <- futurequant - pastquant
# Send appropriate order
entry <- nrow(orderline) + 1
orderline[entry, Con_FieldName_MsgType] <- Con_MsgType_New
orderline[entry, Con_FieldName_OrdID] <- ordercounter
ordercounter <- ordercounter + 1
orderline[entry, Con_FieldName_Sym] <- temp_dframe$Symbol[b]
orderline[entry, Con_FieldName_Qty] <- abs(tradequant)
if (tradequant > 0){
orderline[entry, Con_FieldName_Side] <- Con_Side_Buy
orderline[entry, Con_FieldName_Price] <- tick_data[a+30,"LOW"]
} else{
orderline[entry, Con_FieldName_Side] <- Con_Side_Sell
orderline[entry, Con_FieldName_Price] <- tick_data[a+30,"HIGH"]
}
orderline[entry, Con_FieldName_OrdType] <- Con_OrdType_Mkt
orderline[entry, Con_FieldName_Time] <- as.POSIXct((as.numeric(next_date+60)),origin = "1970-01-01")
print(orderline)
response <- handle_orders(orderline, stock, global_tables, tick_data[a+29, "Date"])
print(response)
}
}
}
a <- a + 30
}
class(orderline$Symbol)
class(stock)
env[["AC_ask"]]
tick_data[a+29, "Date"]
class(tick_data[a+29, "Date"])
stock
>>>>>>> origin/master
