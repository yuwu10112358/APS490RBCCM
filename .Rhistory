<<<<<<< HEAD
=======
<<<<<<< HEAD
#execution message format: orderID, Execstatus, symbol, quantity, avg price, side, time
#Execstatus can be the following: filled, replaced, cancelled, replacereject?, cancelreject
#order book format: orderID, time, symbol, price, quantity, side, ordtype
#trade matrix format: time, symbol, side, quantity, price, open/close, pnl
#position matrix: time, asset, #of shares, book value, market value,
datafile_name = "../data/TSXdatafile.xls"
global_tables = new.env()
global_tables[[Con_GlobalVarName_LOB]]<- data.frame(matrix(0, 0, length(orderbook_spec)))
colnames(global_tables[[Con_GlobalVarName_LOB]]) <- orderbook_spec
#the position book is a list of data frames
init_pos <- data.frame(matrix(0, 1, length(positionbook_spec)))
colnames(init_pos) <- positionbook_spec
init_pos[,Con_FieldName_Sym] = Con_Sym_Cash
init_pos[,c(Con_FieldName_Qty, Con_FieldName_BookVal, Con_FieldName_MktVal)] = init_cash
global_tables[[Con_GlobalVarName_PositionBook]] <- list(init_pos)
names(global_tables[[Con_GlobalVarName_PositionBook]])[1] = 0
global_tables[[Con_GlobalVarName_TradesBook]] <- data.frame(matrix(0, 0, length(tradesbook_spec)))
colnames(global_tables[[Con_GlobalVarName_TradesBook]]) <- tradesbook_spec
global_tables[[Con_GlobalVarName_MktPrice]] <- list(vector())
global_tables[[Con_GlobalVarName_BidPrice]] <- list(vector())
global_tables[[Con_GlobalVarName_AskPrice]] <- list(vector())
global_tables[[Con_GlobalVarName_ListDates]] <- list(vector())
import_data(global_tables)
# constants
jump <- 13
return_and_stdev <- function(prices){
for (i in 2:NROW(prices)){
prices[i, "Return"] <- log10(prices[i,"Price"]/prices[i-1,"Price"])
}
final_return <- mean(na.omit(prices[, "Return"]))
for (i in 2:NROW(prices)){
prices[i, "StDev"] <- (prices[i, "Return"]-final_return)^2
}
final_stdev <- sum(na.omit(prices[, "StDev"]))/(NROW(prices)-1)
return(list(return=final_return, stdev=final_stdev))
}
IPR_df <- data.frame(Date = as.character(), Symbol = as.character(), IPR = as.integer())
# Stocks <- c("AC", "BNS", "BMO")
Stocks <- c("AC")
EquityList <- c("tick", "ask", "bid")
a <- 1
# only trading every 30 minutes, change this value when trading time is different
end_a <- nrow(env[["list_dates"]])*12*30*length(Stocks)
end_a <- 99
# loop through each minute (a) but only calculate IPR every 30 minutes
while (a < end_a){
print(a)
for (stock in Stocks){
stock_data <- paste(stock,EquityList[1],sep="_")
tick_data <- env[[stock_data]]
if (strftime(tick_data[a, "Date"], format="%H:%M:%S") == "15:30:00"){
a <- a + 1
break
=======
>>>>>>> origin/master
}
next_date <- tick_data[a+29, "Date"]
P_asterix <- tick_data[a+29, "LAST_PRICE"]
P_asterix_j_date <-  tick_data[(a+29) - jump, "LAST_PRICE"]
start_row <- 1
end_row <- which(tick_data$Date == next_date)
price_estimates <- data.frame(Price = tick_data[start_row:end_row, "LAST_PRICE"])
ret <- return_and_stdev(price_estimates)$return
stdev <- return_and_stdev(price_estimates)$stdev
z <- (log(P_asterix/P_asterix_j_date) - jump * ret) / (sqrt(jump * stdev))
IPR <- pnorm(z)
IPR_df <- rbind(IPR_df, data.frame(Date = next_date + 60, Symbol = stock, IPR = IPR))
if (stock == Stocks[length(Stocks)]){
temp_dframe <- subset(IPR_df, Date == "2015-05-13 10:00:00")
temp_dframe$Symbol <- as.character(temp_dframe$Symbol)
# order the dataframe based on IPR values
temp_dframe <- temp_dframe[order(temp_dframe$IPR),]
# create buy or sell orders
# Access positionbook, find current stock position and current value
# Sum up all values to get total portfolio value
if (a + 29 == 30){
currposition <- global_tables$positionbook[["0"]]
} else {
currposition <- global_tables[["positionbook"]][[length(global_tables[["positionbook"]])]]
}
totalvalue <- 0
if (nrow(currposition) == 1){
totalvalue <- currposition$MarketValue[1]
>>>>>>> origin/master
} else {
for (s in 2:nrow(currposition)){
stock = currposition$Symbol[s]
stock_data <- paste(stock,EquityList[1],sep="_")
tick_data <- env[[stock_data]]
totalvalue <- currposition$MarketValue[1]
totalvalue <- totalvalue + currposition$Quantity[s]*tick_data[which(tick_data$Date == (next_date+60)),"Date"]
}
}
ordercounter <- 1
orderline = data.frame(matrix(NA, 0, length(order_msg_spec)))
colnames(orderline) <- order_msg_spec
for (b in 1:length(temp_dframe)){
stock = as.character(temp_dframe$Symbol[b])
stock_data <- paste(stock,EquityList[1],sep="_")
tick_data <- env[[stock_data]]
# assign percentages to each stock for cash allocations
cash_alloc <- -(temp_dframe[b, "IPR"]) + 0.5
# send an order to the market with sell and using the existing cash * appropriate Pct
# Calculate dollar value based on percentage cash_alloc * totalvalue
allocvalue <- cash_alloc*totalvalue
# Divide cashalloc*totalvalue by share price to obtain # of shares
futurequant<- floor(allocvalue/tick_data[a+30,"LAST_PRICE"])
# Subtract future # of shares with current number of shares
pastquant = 0
if (sum(currposition$Symbol == stock) == 0){
pastquant = 0
} else {
pastquant = currposition[which(currposition$Symbol == stock),"Quantity"]
}
tradequant <- futurequant - pastquant
# Send appropriate order
entry <- nrow(orderline) + 1
orderline[entry, Con_FieldName_MsgType] <- Con_MsgType_New
orderline[entry, Con_FieldName_OrdID] <- ordercounter
ordercounter <- ordercounter + 1
orderline[entry, Con_FieldName_Sym] <- temp_dframe$Symbol[b]
orderline[entry, Con_FieldName_Qty] <- abs(tradequant)
if (tradequant > 0){
orderline[entry, Con_FieldName_Side] <- Con_Side_Buy
orderline[entry, Con_FieldName_Price] <- tick_data[a+30,"LOW"]
} else{
orderline[entry, Con_FieldName_Side] <- Con_Side_Sell
orderline[entry, Con_FieldName_Price] <- tick_data[a+30,"HIGH"]
}
orderline[entry, Con_FieldName_OrdType] <- Con_OrdType_Mkt
orderline[entry, Con_FieldName_Time] <- as.POSIXct((as.numeric(next_date+60)),origin = "1970-01-01")
print(orderline)
response <- handle_orders(orderline, stock, global_tables, tick_data[a+29, "Date"])
print(response)
}
}
}
a <- a + 30
}
<<<<<<< HEAD
env = global_tables
# constants
jump <- 13
return_and_stdev <- function(prices){
for (i in 2:NROW(prices)){
prices[i, "Return"] <- log10(prices[i,"Price"]/prices[i-1,"Price"])
}
final_return <- mean(na.omit(prices[, "Return"]))
for (i in 2:NROW(prices)){
prices[i, "StDev"] <- (prices[i, "Return"]-final_return)^2
}
final_stdev <- sum(na.omit(prices[, "StDev"]))/(NROW(prices)-1)
return(list(return=final_return, stdev=final_stdev))
=======
class(orderline$Symbol)
class(stock)
env[["AC_ask"]]
tick_data[a+29, "Date"]
class(tick_data[a+29, "Date"])
stock
>>>>>>> origin/master
source('constants.r')
setwd("/Users/jewelho/Desktop/Capstone/Code/APS490RBCCM")
# The "RWeka" package and the options gives more space to store the data
# XLConnect package is for "readWorksheetFromFile" function
options( java.parameters = "-Xmx6g" )
install.packages("RWeka")
library( "RWeka" )
install.packages("XLConnect")
library(XLConnect)
# Instructions on how to use get data
# 0. CHANGE WORKING DIRECTOR & "filename"
# 1.Run the code separately (or else it will take a long time to run)
# 2.Load data: change stock symbols then run "data_extraction"
# 3.Data cleaning: Run data_cleaning and data_cleaning2 separately
# 4.Done. Want to check what the data looks like? Run the commented lines below
# head(global_tables[["BMO_tick"]])
# tail(global_tables[["SPTSX_ask"]][1,1])
#=================================================================
#available stocks: AC,BNS,BMO,SPTSX
env <- global_tables
symbol <- "BNS"
# the symbol is the same as the excel tab name
tick_name <-"BNS_tick"
bid_name <-"BNS_bid"
ask_name <-"BNS_ask"
filename <- "/Users/jewelho/dropbox/Capstone_Data_TSX/TSXdatafile.xlsx"
#=======================================================================
EquityList <- c(tick_name,bid_name,ask_name)
#data_extraction(filename, env, symbol, tick_name, bid_name, ask_name)
for (Name in EquityList) {
#data_cleaning(filename, env, symbol, tick_name, bid_name, ask_name,Name)
#data_cleaning2(filename, env, symbol, tick_name, bid_name, ask_name,Name)
}
data_extraction <- function(filename, env, symbol, tick_name, bid_name, ask_name)
{
#Definition: This function creates tables (tick, bid and ask) of stock prices. It imports stock price data from an Excel file that links to the Bloomberg terminal.
#Requirements:
#The excel sheet contains 3 tables arranged in order: Tick, Ask, Bid price.
#Number of columns in each table can vary
file <- readWorksheetFromFile(filename,
sheet= symbol,
startRow = 3,
check.names = FALSE
)
#file <- read.xlsx(filename, sheet= symbol, startRow = 3,check.names = FALSE)
mylist = c()
mylist[1] = 1
for(i in 1:length(file)){
if(is.na(file[,i])) {
mylist[length(mylist)+1] = i
}}
env[[tick_name]] = file[, mylist[1]:   (mylist[2] - 1)]
env[[bid_name]]  = file[,(mylist[2]+1):(mylist[3] - 1)]
env[[ask_name]]  = file[,(mylist[3]+1):length(file)]
# only consider complete cases (remove NA)
#env[[bid_name]][complete.cases(env[[bid_name]]),]
#env[[ask_name]][complete.cases(env[[ask_name]]),]
}
data_cleaning <- function(filename, env, symbol, tick_name, bid_name, ask_name,Name){
# Remove NA col
maxrow <- nrow(env[[Name]])
env[[Name]] = env[[Name]][complete.cases(env[[Name]][1:maxrow,] ) ,]
# maxrow <- nrow(env[[tick_name]])
# global_tables[["ABX_tick"]] = global_tables[["ABX_tick"]][complete.cases(global_tables[["ABX_tick"]][1:maxrow,] ) ,]
}
data_cleaning2 <- function(filename, env, symbol, tick_name, bid_name, ask_name,Name){
# Remove close market data
Opentime <- as.POSIXct("2000-01-01 09:30:00", tz = "EST")
Opentime <-strftime(Opentime, format="%H:%M:%S")
Closetime <- as.POSIXct("2000-01-01 16:00:00", tz = "EST")
Closetime <-strftime(Closetime, format="%H:%M:%S")
row_to_keep <- logical(length = nrow(env[[Name]]) )
for (i in 1:nrow(env[[Name]])){
temp <- strftime(env[[Name]][i,1], format="%H:%M:%S")
if ( temp >= Opentime && temp <= Closetime){
row_to_keep[i] <- TRUE
}else {
row_to_keep[i] <- FALSE
}
}
env[[Name]] = env[[Name]][row_to_keep,]
}
getquotes<-function(env,symbol,time){
# return (Nstocks * rows)
# if no quote then return empty
# aftermarket hour, 930-4 then return empty
#===========================================
# this function returns an updated mkt_quote table
mkt_quote = data.frame(matrix(NA, length(symbol), length(mkt_quote_spec)))
colnames(mkt_quote) <- mkt_quote_spec
time_930 <- get_time_since_open(as.POSIXct("2000-01-01 09:30:00", tz = "EST"))
time_931 <- get_time_since_open(as.POSIXct("2000-01-01 09:31:00", tz = "EST"))
time_1559 <- get_time_since_open(as.POSIXct("2000-01-01 15:59:00", tz = "EST"))
time_1600 <- get_time_since_open(as.POSIXct("2000-01-01 16:00:00", tz = "EST"))
for (i in 1:length(symbol)){
#time <- "2000-01-01 09:30:00 EST"
datatable_name_tick <- paste(symbol[i], Con_Data_Tick_Suffix, sep = "")
datatable_name_bid <- paste(symbol[i], Con_Data_Bid_Suffix, sep = "")
datatable_name_ask <- paste(symbol[i], Con_Data_Ask_Suffix, sep = "")
time_since_open <- get_time_since_open(as.POSIXct(time))
if (time_since_open == time_930){
# 9:30 then opening tick for 5 prices, val/vol/tick = 0
j <- (1:nrow(env[[datatable_name_tick]]))[env[[datatable_name_tick]][[Con_Data_ColName_Date]] == time]
mkt_quote[i, Con_FieldName_Sym] <- symbol[i]
mkt_quote[i, Con_FieldName_CurrentBid] <- env[[datatable_name_tick]][[Con_Data_ColName_Open]][j]
mkt_quote[i, Con_FieldName_CurrentAsk] <- env[[datatable_name_tick]][[Con_Data_ColName_Open]][j]
mkt_quote[i, Con_FieldName_CurrentTick] <- env[[datatable_name_tick]][[Con_Data_ColName_Open]][j]
mkt_quote[i, Con_FieldName_LastHighestBid] <- env[[datatable_name_tick]][[Con_Data_ColName_Open]][j]
mkt_quote[i, Con_FieldName_LastLowestAsk] <- env[[datatable_name_tick]][[Con_Data_ColName_Open]][j]
mkt_quote[i, Con_Data_ColName_LastNumTicks] <- 0
mkt_quote[i, Con_Data_ColName_LastVolume] <- 0
mkt_quote[i, Con_Data_ColName_LastValue] <- 0
}
else if (time_since_open == time_1600){
# 15:59 close tick,val/vol/tick
j <- (1:nrow(env[[datatable_name_tick]]))[env[[datatable_name_tick]][[Con_Data_ColName_Date]] == time - 60]
mkt_quote[i, Con_FieldName_Sym] <- symbol[i]
mkt_quote[i, Con_FieldName_CurrentBid] <- env[[datatable_name_tick]][[Con_Data_ColName_LastPrice]][j]
mkt_quote[i, Con_FieldName_CurrentAsk] <- env[[datatable_name_tick]][[Con_Data_ColName_LastPrice]][j]
mkt_quote[i, Con_FieldName_CurrentTick] <- env[[datatable_name_tick]][[Con_Data_ColName_LastPrice]][j]
mkt_quote[i, Con_FieldName_LastHighestBid] <- env[[datatable_name_bid]][[Con_Data_ColName_High]][j]
mkt_quote[i, Con_FieldName_LastLowestAsk] <- env[[datatable_name_ask]][[Con_Data_ColName_Low]][j]
mkt_quote[i, Con_Data_ColName_LastNumTicks] <- env[[datatable_name_tick]][[Con_Data_ColName_NumTicks]][j]
mkt_quote[i, Con_Data_ColName_LastVolume] <- env[[datatable_name_tick]][[Con_Data_ColName_Volume]][j]
mkt_quote[i, Con_Data_ColName_LastValue] <- env[[datatable_name_tick]][[Con_Data_ColName_Value]][j]
}
else if (time_since_open >= time_931 & time_since_open <= time_1559){
j <- (1:nrow(env[[datatable_name_tick]]))[env[[datatable_name_tick]][[Con_Data_ColName_Date]] == time]
mkt_quote[i, Con_FieldName_Sym] <- symbol[i]
mkt_quote[i, Con_FieldName_CurrentBid] <- env[[datatable_name_bid]][[Con_Data_ColName_Open]][j]
mkt_quote[i, Con_FieldName_CurrentAsk] <- env[[datatable_name_ask]][[Con_Data_ColName_Open]][j]
mkt_quote[i, Con_FieldName_CurrentTick] <- env[[datatable_name_tick]][[Con_Data_ColName_Open]][j]
mkt_quote[i, Con_FieldName_LastHighestBid] <- env[[datatable_name_bid]][[Con_Data_ColName_High]][j-1]
mkt_quote[i, Con_FieldName_LastLowestAsk] <- env[[datatable_name_ask]][[Con_Data_ColName_Low]][j-1]
mkt_quote[i, Con_Data_ColName_LastNumTicks] <- env[[datatable_name_tick]][[Con_Data_ColName_NumTicks]][j-1]
mkt_quote[i, Con_Data_ColName_LastVolume] <- env[[datatable_name_tick]][[Con_Data_ColName_Volume]][j-1]
mkt_quote[i, Con_Data_ColName_LastValue] <- env[[datatable_name_tick]][[Con_Data_ColName_Value]][j-1]
}
else{
}
}
# this function returns an updated mkt_quote table
return (mkt_quote)
}
data_extraction(filename, env, symbol, tick_name, bid_name, ask_name)
for (Name in EquityList) {
data_cleaning(filename, env, symbol, tick_name, bid_name, ask_name,Name)
data_cleaning2(filename, env, symbol, tick_name, bid_name, ask_name,Name)
>>>>>>> origin/master
}
head(global_tables[["BNS_tick"]])
head(global_tables[["BNS_tick"]][1,1])
head(global_tables[["BNS_tick"]][12,1])
getquotes(global_tables,"BNS","2015-05-13 09:41:00 EDT")
Stocks <- c("AC", "BNS", "BMO")
EquityList <- c("tick", "ask", "bid")
#EquityList <- c(tick_name,bid_name,ask_name)
for (stock in Stocks){
for (name in EquityList){
stock_data <- paste(stock,name,sep="_")
assign(paste(stock,name,sep="_"), env[[stock_data]])
}
}
<<<<<<< HEAD
totalvalue <- 0
if (nrow(currposition) == 1){
totalvalue <- currposition$MarketValue[1]
} else {
for (s in 2:nrow(currposition)){
stock = currposition$Symbol[s]
stock_data <- paste(stock,EquityList[1],sep="_")
tick_data <- env[[stock_data]]
totalvalue <- currposition$MarketValue[1]
totalvalue <- totalvalue + currposition$Quantity[s]*tick_data[which(tick_data$Date == (next_date+60)),"Date"]
}
}
ordercounter <- 1
orderline = data.frame(matrix(NA, 0, length(order_msg_spec)))
colnames(orderline) <- order_msg_spec
for (b in 1:length(temp_dframe)){
stock = as.character(temp_dframe$Symbol[b])
stock_data <- paste(stock,EquityList[1],sep="_")
tick_data <- env[[stock_data]]
# assign percentages to each stock for cash allocations
cash_alloc <- -(temp_dframe[b, "IPR"]) + 0.5
# send an order to the market with sell and using the existing cash * appropriate Pct
# Calculate dollar value based on percentage cash_alloc * totalvalue
allocvalue <- cash_alloc*totalvalue
# Divide cashalloc*totalvalue by share price to obtain # of shares
futurequant<- floor(allocvalue/tick_data[a+30,"LAST_PRICE"])
# Subtract future # of shares with current number of shares
pastquant = 0
if (sum(currposition$Symbol == stock) == 0){
pastquant = 0
} else {
pastquant = currposition[which(currposition$Symbol == stock),"Quantity"]
}
tradequant <- futurequant - pastquant
# Send appropriate order
entry <- nrow(orderline) + 1
orderline[entry, Con_FieldName_MsgType] <- Con_MsgType_New
orderline[entry, Con_FieldName_OrdID] <- ordercounter
ordercounter <- ordercounter + 1
orderline[entry, Con_FieldName_Sym] <- temp_dframe$Symbol[b]
orderline[entry, Con_FieldName_Qty] <- abs(tradequant)
if (tradequant > 0){
orderline[entry, Con_FieldName_Side] <- Con_Side_Buy
orderline[entry, Con_FieldName_Price] <- tick_data[a+30,"LOW"]
} else{
orderline[entry, Con_FieldName_Side] <- Con_Side_Sell
orderline[entry, Con_FieldName_Price] <- tick_data[a+30,"HIGH"]
}
orderline[entry, Con_FieldName_OrdType] <- Con_OrdType_Mkt
orderline[entry, Con_FieldName_Time] <- as.POSIXct((as.numeric(next_date+60)),origin = "1970-01-01")
print(orderline)
response <- handle_orders(orderline, stock, global_tables, tick_data[a+29, "Date"])
print(response)
}
}
}
a <- a + 30
}
currposition
global_tables$positionbook
global_tables[["positionbook"]][[length(global_tables[["positionbook"]])]]
a
# constants
jump <- 13
return_and_stdev <- function(prices){
for (i in 2:NROW(prices)){
prices[i, "Return"] <- log10(prices[i,"Price"]/prices[i-1,"Price"])
}
final_return <- mean(na.omit(prices[, "Return"]))
for (i in 2:NROW(prices)){
prices[i, "StDev"] <- (prices[i, "Return"]-final_return)^2
}
final_stdev <- sum(na.omit(prices[, "StDev"]))/(NROW(prices)-1)
return(list(return=final_return, stdev=final_stdev))
}
IPR_df <- data.frame(Date = as.character(), Symbol = as.character(), IPR = as.integer())
# Stocks <- c("AC", "BNS", "BMO")
Stocks <- c("AC")
EquityList <- c("tick", "ask", "bid")
a <- 1
# only trading every 30 minutes, change this value when trading time is different
end_a <- nrow(env[["list_dates"]])*12*30*length(Stocks)
end_a <- 99
# loop through each minute (a) but only calculate IPR every 30 minutes
while (a < end_a){
print(a)
for (stock in Stocks){
stock_data <- paste(stock,EquityList[1],sep="_")
tick_data <- env[[stock_data]]
if (strftime(tick_data[a, "Date"], format="%H:%M:%S") == "15:30:00"){
a <- a + 1
break
}
next_date <- tick_data[a+29, "Date"]
P_asterix <- tick_data[a+29, "LAST_PRICE"]
P_asterix_j_date <-  tick_data[(a+29) - jump, "LAST_PRICE"]
start_row <- 1
end_row <- which(tick_data$Date == next_date)
price_estimates <- data.frame(Price = tick_data[start_row:end_row, "LAST_PRICE"])
ret <- return_and_stdev(price_estimates)$return
stdev <- return_and_stdev(price_estimates)$stdev
z <- (log(P_asterix/P_asterix_j_date) - jump * ret) / (sqrt(jump * stdev))
IPR <- pnorm(z)
IPR_df <- rbind(IPR_df, data.frame(Date = next_date + 60, Symbol = stock, IPR = IPR))
if (stock == Stocks[length(Stocks)]){
temp_dframe <- subset(IPR_df, Date == "2015-05-13 10:00:00")
temp_dframe$Symbol <- as.character(temp_dframe$Symbol)
# order the dataframe based on IPR values
temp_dframe <- temp_dframe[order(temp_dframe$IPR),]
# create buy or sell orders
# Access positionbook, find current stock position and current value
# Sum up all values to get total portfolio value
if (a + 29 == 30){
currposition <- global_tables$positionbook[["0"]]
} else {
currposition <- global_tables[["positionbook"]][[length(global_tables[["positionbook"]])]]
}
totalvalue <- 0
if (nrow(currposition) == 1){
totalvalue <- currposition$MarketValue[1]
} else {
for (s in 2:nrow(currposition)){
stock = currposition$Symbol[s]
stock_data <- paste(stock,EquityList[1],sep="_")
tick_data <- env[[stock_data]]
totalvalue <- currposition$MarketValue[1]
totalvalue <- totalvalue + currposition$Quantity[s]*tick_data[which(tick_data$Date == (next_date+60)),"Date"]
}
}
ordercounter <- 1
orderline = data.frame(matrix(NA, 0, length(order_msg_spec)))
colnames(orderline) <- order_msg_spec
for (b in 1:length(temp_dframe)){
stock = as.character(temp_dframe$Symbol[b])
stock_data <- paste(stock,EquityList[1],sep="_")
tick_data <- env[[stock_data]]
# assign percentages to each stock for cash allocations
cash_alloc <- -(temp_dframe[b, "IPR"]) + 0.5
# send an order to the market with sell and using the existing cash * appropriate Pct
# Calculate dollar value based on percentage cash_alloc * totalvalue
allocvalue <- cash_alloc*totalvalue
# Divide cashalloc*totalvalue by share price to obtain # of shares
futurequant<- floor(allocvalue/tick_data[a+30,"LAST_PRICE"])
# Subtract future # of shares with current number of shares
pastquant = 0
if (sum(currposition$Symbol == stock) == 0){
pastquant = 0
} else {
pastquant = currposition[which(currposition$Symbol == stock),"Quantity"]
}
tradequant <- futurequant - pastquant
# Send appropriate order
entry <- nrow(orderline) + 1
orderline[entry, Con_FieldName_MsgType] <- Con_MsgType_New
orderline[entry, Con_FieldName_OrdID] <- ordercounter
ordercounter <- ordercounter + 1
orderline[entry, Con_FieldName_Sym] <- temp_dframe$Symbol[b]
orderline[entry, Con_FieldName_Qty] <- abs(tradequant)
if (tradequant > 0){
orderline[entry, Con_FieldName_Side] <- Con_Side_Buy
orderline[entry, Con_FieldName_Price] <- tick_data[a+30,"LOW"]
} else{
orderline[entry, Con_FieldName_Side] <- Con_Side_Sell
orderline[entry, Con_FieldName_Price] <- tick_data[a+30,"HIGH"]
}
orderline[entry, Con_FieldName_OrdType] <- Con_OrdType_Mkt
orderline[entry, Con_FieldName_Time] <- as.POSIXct((as.numeric(next_date+60)),origin = "1970-01-01")
}
print(orderline)
response <- handle_orders(orderline, Stocks, global_tables, tick_data[a+29, "Date"])
print(response)
}
}
a <- a + 30
}
init_cash = 100000
#global_variables: position matrices, trade matrices, ourdata, order book
#order format: msgtype, symbol, price, quantity, side, ordtype, orderID, time
#execution message format: orderID, Execstatus, symbol, quantity, avg price, side, time
#Execstatus can be the following: filled, replaced, cancelled, replacereject?, cancelreject
#order book format: orderID, time, symbol, price, quantity, side, ordtype
#trade matrix format: time, symbol, side, quantity, price, open/close, pnl
#position matrix: time, asset, #of shares, book value, market value,
datafile_name = "../data/TSXdatafile.xls"
global_tables = new.env()
global_tables[[Con_GlobalVarName_LOB]]<- data.frame(matrix(0, 0, length(orderbook_spec)))
colnames(global_tables[[Con_GlobalVarName_LOB]]) <- orderbook_spec
#the position book is a list of data frames
init_pos <- data.frame(matrix(0, 1, length(positionbook_spec)))
colnames(init_pos) <- positionbook_spec
init_pos[,Con_FieldName_Sym] = Con_Sym_Cash
init_pos[,c(Con_FieldName_Qty, Con_FieldName_BookVal, Con_FieldName_MktVal)] = init_cash
global_tables[[Con_GlobalVarName_PositionBook]] <- list(init_pos)
names(global_tables[[Con_GlobalVarName_PositionBook]])[1] = 0
global_tables[[Con_GlobalVarName_TradesBook]] <- data.frame(matrix(0, 0, length(tradesbook_spec)))
colnames(global_tables[[Con_GlobalVarName_TradesBook]]) <- tradesbook_spec
global_tables[[Con_GlobalVarName_MktPrice]] <- list(vector())
global_tables[[Con_GlobalVarName_BidPrice]] <- list(vector())
global_tables[[Con_GlobalVarName_AskPrice]] <- list(vector())
global_tables[[Con_GlobalVarName_ListDates]] <- list(vector())
# constants
jump <- 13
return_and_stdev <- function(prices){
for (i in 2:NROW(prices)){
prices[i, "Return"] <- log10(prices[i,"Price"]/prices[i-1,"Price"])
}
final_return <- mean(na.omit(prices[, "Return"]))
for (i in 2:NROW(prices)){
prices[i, "StDev"] <- (prices[i, "Return"]-final_return)^2
}
final_stdev <- sum(na.omit(prices[, "StDev"]))/(NROW(prices)-1)
return(list(return=final_return, stdev=final_stdev))
}
IPR_df <- data.frame(Date = as.character(), Symbol = as.character(), IPR = as.integer())
# Stocks <- c("AC", "BNS", "BMO")
Stocks <- c("AC")
=======
stock_data
assign
stock_data
AC_ask
symbol <- "BNS"
EquityList <- c("tick", "ask", "bid")
#EquityList <- c(tick_name,bid_name,ask_name)
for (name in EquityList){
stock_data <- paste(symbol,name,sep="_")
#assign(paste(stock,name,sep="_"), env[[stock_data]])
}
stock_data
?assign
env <- global_tables
symbol <- "BNS"
# the symbol is the same as the excel tab name
#tick_name <-"BNS_tick"
#bid_name <-"BNS_bid"
#ask_name <-"BNS_ask"
filename <- "/Users/jewelho/dropbox/Capstone_Data_TSX/TSXdatafile.xlsx"
#=======================================================================
>>>>>>> origin/master
EquityList <- c("tick", "ask", "bid")
#EquityList <- c(tick_name,bid_name,ask_name)
for (i in 1:3){
for (name in EquityList){
stock_data[i] <- paste(symbol,name,sep="_")
}
}
<<<<<<< HEAD
orderline[entry, Con_FieldName_OrdType] <- Con_OrdType_Mkt
orderline[entry, Con_FieldName_Time] <- as.POSIXct((as.numeric(next_date+60)),origin = "1970-01-01")
}
print(orderline)
response <- handle_orders(orderline, Stocks, global_tables, tick_data[a+29, "Date"])
print(response)
=======
stock_data
EquityList <- c("tick", "ask", "bid")
#EquityList <- c(tick_name,bid_name,ask_name)
for (i in 1:3){
stock_data[i] <- paste(symbol,EquityList[i],sep="_")
>>>>>>> origin/master
}
stock_data
data_extraction(filename, env, symbol, stock_name[1], stock_name[2], stock_name[3])
for (Name in stock_name) {
data_cleaning(filename, env, symbol, tick_name, bid_name, ask_name,Name)
data_cleaning2(filename, env, symbol, tick_name, bid_name, ask_name,Name)
}
<<<<<<< HEAD
a <- a + 30
}
currposition
currposition$Symbol == stock
currposition$Symbol
currposition$Symbol == stock
stock
stock = as.character(temp_dframe$Symbol[b])
stock
=======
stock_name
EquityList <- c("tick", "ask", "bid")
for (i in 1:3){
stock_name[i] <- paste(symbol,EquityList[i],sep="_")
}
stock_name = c()
EquityList <- c("tick", "ask", "bid")
for (i in 1:3){
stock_name[i] <- paste(symbol,EquityList[i],sep="_")
}
stock_name
data_extraction(filename, env, symbol, stock_name[1], stock_name[2], stock_name[3])
for (Name in stock_name) {
data_cleaning(filename, env, symbol, tick_name, bid_name, ask_name,Name)
data_cleaning2(filename, env, symbol, tick_name, bid_name, ask_name,Name)
}
stock_name
stock_name
source('constants.r')
setwd("/Users/jewelho/Desktop/Capstone/Code/APS490RBCCM")
# The "RWeka" package and the options gives more space to store the data
# XLConnect package is for "readWorksheetFromFile" function
options( java.parameters = "-Xmx6g" )
install.packages("RWeka")
library( "RWeka" )
install.packages("XLConnect")
library(XLConnect)
# Instructions on how to use get data
# 0. CHANGE WORKING DIRECTOR & "filename"
# 1.Run the code separately (or else it will take a long time to run)
# 2.Load data: change stock symbols then run "data_extraction"
# 3.Data cleaning: Run data_cleaning and data_cleaning2 separately
# 4.Done. Want to check what the data looks like? Run the commented lines below
# head(global_tables[["BMO_tick"]])
# tail(global_tables[["SPTSX_ask"]][1,1])
#=================================================================
#available stocks: AC,BNS,BMO,SPTSX
env <- global_tables
symbol <- "BNS"
filename <- "/Users/jewelho/dropbox/Capstone_Data_TSX/TSXdatafile.xlsx"
#=======================================================================
stock_name = c()
EquityList <- c("tick", "ask", "bid")
for (i in 1:3){stock_name[i] <- paste(symbol,EquityList[i],sep="_")}
#data_extraction(filename, env, symbol, stock_name[1], stock_name[2], stock_name[3])
for (Name in stock_name) {
#data_cleaning(filename, env, symbol,Name)
#data_cleaning2(filename, env, symbol,Name)
}
#=====================================================================================
data_extraction <- function(filename, env, symbol, tick_name, bid_name, ask_name){
#Definition: This function creates tables (tick, bid and ask) of stock prices. It imports stock price data from an Excel file that links to the Bloomberg terminal.
#The excel sheet contains 3 tables arranged in order: Tick, Ask, Bid price.
#Number of columns in each table can vary
file <- readWorksheetFromFile(filename,sheet= symbol, startRow = 3,check.names = FALSE)
mylist = c()
mylist[1] = 1
for(i in 1:length(file)){
if(is.na(file[,i])) {
mylist[length(mylist)+1] = i
}}
env[[tick_name]] = file[, mylist[1]:   (mylist[2] - 1)]
env[[bid_name]]  = file[,(mylist[2]+1):(mylist[3] - 1)]
env[[ask_name]]  = file[,(mylist[3]+1):length(file)]
}
data_cleaning <- function(filename, env, symbol,Name){
# Remove NA col
maxrow <- nrow(env[[Name]])
env[[Name]] = env[[Name]][complete.cases(env[[Name]][1:maxrow,] ) ,]
# maxrow <- nrow(env[[tick_name]])
# global_tables[["ABX_tick"]] = global_tables[["ABX_tick"]][complete.cases(global_tables[["ABX_tick"]][1:maxrow,] ) ,]
}
data_cleaning2 <- function(filename, env, symbol,Name){
# Remove close market data
Opentime <- as.POSIXct("2000-01-01 09:30:00", tz = "EST")
Opentime <-strftime(Opentime, format="%H:%M:%S")
Closetime <- as.POSIXct("2000-01-01 16:00:00", tz = "EST")
Closetime <-strftime(Closetime, format="%H:%M:%S")
row_to_keep <- logical(length = nrow(env[[Name]]) )
for (i in 1:nrow(env[[Name]])){
temp <- strftime(env[[Name]][i,1], format="%H:%M:%S")
if ( temp >= Opentime && temp <= Closetime){
row_to_keep[i] <- TRUE
}else {
row_to_keep[i] <- FALSE
}
}
env[[Name]] = env[[Name]][row_to_keep,]
}
#getquotes(global_tables,c("BNS"","2015-05-13 09:41:00 EDT")
getquotes<-function(env,symbol,time)
{
# return (Nstocks * rows)
# if no quote then return empty
# aftermarket hour, 930-4 then return empty
# this function returns an updated mkt_quote table
mkt_quote = data.frame(matrix(NA, length(symbol), length(mkt_quote_spec)))
colnames(mkt_quote) <- mkt_quote_spec
time_930 <- get_time_since_open(as.POSIXct("2000-01-01 09:30:00", tz = "EST"))
time_931 <- get_time_since_open(as.POSIXct("2000-01-01 09:31:00", tz = "EST"))
time_1559 <- get_time_since_open(as.POSIXct("2000-01-01 15:59:00", tz = "EST"))
time_1600 <- get_time_since_open(as.POSIXct("2000-01-01 16:00:00", tz = "EST"))
for (i in 1:length(symbol)){
#time <- "2000-01-01 09:30:00 EST"
datatable_name_tick <- paste(symbol[i], Con_Data_Tick_Suffix, sep = "")
datatable_name_bid <- paste(symbol[i], Con_Data_Bid_Suffix, sep = "")
datatable_name_ask <- paste(symbol[i], Con_Data_Ask_Suffix, sep = "")
time_since_open <- get_time_since_open(as.POSIXct(time))
if (time_since_open == time_930){
# 9:30 then opening tick for 5 prices, val/vol/tick = 0
j <- (1:nrow(env[[datatable_name_tick]]))[env[[datatable_name_tick]][[Con_Data_ColName_Date]] == time]
mkt_quote[i, Con_FieldName_Sym] <- symbol[i]
mkt_quote[i, Con_FieldName_CurrentBid] <- env[[datatable_name_tick]][[Con_Data_ColName_Open]][j]
mkt_quote[i, Con_FieldName_CurrentAsk] <- env[[datatable_name_tick]][[Con_Data_ColName_Open]][j]
mkt_quote[i, Con_FieldName_CurrentTick] <- env[[datatable_name_tick]][[Con_Data_ColName_Open]][j]
mkt_quote[i, Con_FieldName_LastHighestBid] <- env[[datatable_name_tick]][[Con_Data_ColName_Open]][j]
mkt_quote[i, Con_FieldName_LastLowestAsk] <- env[[datatable_name_tick]][[Con_Data_ColName_Open]][j]
mkt_quote[i, Con_Data_ColName_LastNumTicks] <- 0
mkt_quote[i, Con_Data_ColName_LastVolume] <- 0
mkt_quote[i, Con_Data_ColName_LastValue] <- 0
}
else if (time_since_open == time_1600){
# 15:59 close tick,val/vol/tick
j <- (1:nrow(env[[datatable_name_tick]]))[env[[datatable_name_tick]][[Con_Data_ColName_Date]] == time - 60]
mkt_quote[i, Con_FieldName_Sym] <- symbol[i]
mkt_quote[i, Con_FieldName_CurrentBid] <- env[[datatable_name_tick]][[Con_Data_ColName_LastPrice]][j]
mkt_quote[i, Con_FieldName_CurrentAsk] <- env[[datatable_name_tick]][[Con_Data_ColName_LastPrice]][j]
mkt_quote[i, Con_FieldName_CurrentTick] <- env[[datatable_name_tick]][[Con_Data_ColName_LastPrice]][j]
mkt_quote[i, Con_FieldName_LastHighestBid] <- env[[datatable_name_bid]][[Con_Data_ColName_High]][j]
mkt_quote[i, Con_FieldName_LastLowestAsk] <- env[[datatable_name_ask]][[Con_Data_ColName_Low]][j]
mkt_quote[i, Con_Data_ColName_LastNumTicks] <- env[[datatable_name_tick]][[Con_Data_ColName_NumTicks]][j]
mkt_quote[i, Con_Data_ColName_LastVolume] <- env[[datatable_name_tick]][[Con_Data_ColName_Volume]][j]
mkt_quote[i, Con_Data_ColName_LastValue] <- env[[datatable_name_tick]][[Con_Data_ColName_Value]][j]
}
else if (time_since_open >= time_931 & time_since_open <= time_1559){
j <- (1:nrow(env[[datatable_name_tick]]))[env[[datatable_name_tick]][[Con_Data_ColName_Date]] == time]
mkt_quote[i, Con_FieldName_Sym] <- symbol[i]
mkt_quote[i, Con_FieldName_CurrentBid] <- env[[datatable_name_bid]][[Con_Data_ColName_Open]][j]
mkt_quote[i, Con_FieldName_CurrentAsk] <- env[[datatable_name_ask]][[Con_Data_ColName_Open]][j]
mkt_quote[i, Con_FieldName_CurrentTick] <- env[[datatable_name_tick]][[Con_Data_ColName_Open]][j]
mkt_quote[i, Con_FieldName_LastHighestBid] <- env[[datatable_name_bid]][[Con_Data_ColName_High]][j-1]
mkt_quote[i, Con_FieldName_LastLowestAsk] <- env[[datatable_name_ask]][[Con_Data_ColName_Low]][j-1]
mkt_quote[i, Con_Data_ColName_LastNumTicks] <- env[[datatable_name_tick]][[Con_Data_ColName_NumTicks]][j-1]
mkt_quote[i, Con_Data_ColName_LastVolume] <- env[[datatable_name_tick]][[Con_Data_ColName_Volume]][j-1]
mkt_quote[i, Con_Data_ColName_LastValue] <- env[[datatable_name_tick]][[Con_Data_ColName_Value]][j-1]
}
else{
}
}
# this function returns an updated mkt_quote table
return (mkt_quote)
}
data_extraction(filename, env, symbol, stock_name[1], stock_name[2], stock_name[3])
for (Name in stock_name) {
data_cleaning(filename, env, symbol,Name)
data_cleaning2(filename, env, symbol,Name)
}
BN
global_tables[[BNS]]
global_tables[["BNS"]]
global_tables[["BNS_ask"]]
getquotes(global_tables,c("BNS"","2015-05-13 09:41:00 EDT")
getquotes(global_tables,c("BNS","2015-05-13 09:41:00 EDT")
)
getquotes(global_tables,"BNS","2015-05-13 09:41:00 EDT"))
getquotes(global_tables,"BNS","2015-05-13 09:41:00 EDT")
getquotes(global_tables,"BNS","2015-05-13 09:42:00 EDT")
getquotes(global_tables,"BNS","2015-05-13 10:42:00 EDT")
symbol <- "AC"
data_extraction <- function(filename, env, symbol, tick_name, bid_name, ask_name){
#Definition: This function creates tables (tick, bid and ask) of stock prices. It imports stock price data from an Excel file that links to the Bloomberg terminal.
#The excel sheet contains 3 tables arranged in order: Tick, Ask, Bid price.
#Number of columns in each table can vary
file <- readWorksheetFromFile(filename,sheet= symbol, startRow = 3,check.names = FALSE)
mylist = c()
mylist[1] = 1
for(i in 1:length(file)){
if(is.na(file[,i])) {
mylist[length(mylist)+1] = i
}}
env[[tick_name]] = file[, mylist[1]:   (mylist[2] - 1)]
env[[bid_name]]  = file[,(mylist[2]+1):(mylist[3] - 1)]
env[[ask_name]]  = file[,(mylist[3]+1):length(file)]
}
data_cleaning <- function(filename, env, symbol,Name){
# Remove NA col
maxrow <- nrow(env[[Name]])
env[[Name]] = env[[Name]][complete.cases(env[[Name]][1:maxrow,] ) ,]
# maxrow <- nrow(env[[tick_name]])
# global_tables[["ABX_tick"]] = global_tables[["ABX_tick"]][complete.cases(global_tables[["ABX_tick"]][1:maxrow,] ) ,]
}
data_cleaning2 <- function(filename, env, symbol,Name){
# Remove close market data
Opentime <- as.POSIXct("2000-01-01 09:30:00", tz = "EST")
Opentime <-strftime(Opentime, format="%H:%M:%S")
Closetime <- as.POSIXct("2000-01-01 16:00:00", tz = "EST")
Closetime <-strftime(Closetime, format="%H:%M:%S")
row_to_keep <- logical(length = nrow(env[[Name]]) )
for (i in 1:nrow(env[[Name]])){
temp <- strftime(env[[Name]][i,1], format="%H:%M:%S")
if ( temp >= Opentime && temp <= Closetime){
row_to_keep[i] <- TRUE
}else {
row_to_keep[i] <- FALSE
}
}
env[[Name]] = env[[Name]][row_to_keep,]
}
stock_name = c()
EquityList <- c("tick", "ask", "bid")
for (i in 1:3){stock_name[i] <- paste(symbol,EquityList[i],sep="_")}
data_extraction(filename, env, symbol, stock_name[1], stock_name[2], stock_name[3])
for (Name in stock_name) {
data_cleaning(filename, env, symbol,Name)
data_cleaning2(filename, env, symbol,Name)
}
head(global_tables[[AC_tick]])
head(global_tables[["AC_tick"]])
getquotes(global_tables,"AC","2015-05-13 10:42:00 EDT")
getquotes(global_tables,c("AC","BNS"),"2015-05-13 10:42:00 EDT")
<<<<<<< HEAD
clc
source('data_cleaning_jewel.r')
env <-global_tables
symbol <- "BNS"
timestamp <- "2015-05-13 09:41:00 EDT"
orderbook <- env[[Con_GlobalVarName_LOB]]
quotes <- getquotes(env, symbol, timestamp)
quotes
symbols_on_book <- orderbook[, Con_FieldName_Sym]
dim(symbols_on_book) <- length(symbols_on_book)
symbols_on_book
dim(symbols_on_book)
orderbook
env <-global_tables
symbol <- "BNS"
timestamp <- "2015-05-13 09:41:00 EDT"
orderbook <- env[[Con_GlobalVarName_LOB]]
quotes <- getquotes(env, symbol, timestamp)
symbols_on_book <- orderbook[, Con_FieldName_Sym]
dim(symbols_on_book) <- length(symbols_on_book)
dim(symbols_on_book)
quotes
symbols_on_book <- orderbook[, Con_FieldName_Sym]
symbols_on_book
sym
orderbook
quotes
orderbook
=======
>>>>>>> origin/master
>>>>>>> origin/master
