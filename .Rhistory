<<<<<<< HEAD
=======
<<<<<<< Updated upstream
<<<<<<< HEAD
startRow = 3,
check.names = FALSE
)
options(java.parameters = "-Xmx4g" )
file <- readWorksheetFromFile("E:/YEAR 4/Code/APS490RBCCM/Intraday_Test_Data.xlsx",
sheet=1,
startRow = 3,
check.names = FALSE
)
file <- readWorksheetFromFile("E:/YEAR 4/Code/APS490RBCCM/Intraday_Test_Data1.xls",
sheet=1,
startRow = 3,
>>>>>>> origin/master
check.names = FALSE
)
mylist = c()
mylist[1] = 1
for(i in 1:length(file)){
if(is.na(file[,i])) {
mylist[length(mylist)+1] = i
}}
tick = file[, mylist[1]:   (mylist[2] - 1)]
bid  = file[,(mylist[2]+1):(mylist[3] - 1)]
ask  = file[,(mylist[3]+1):length(file)]
library(XLConnect)
file <- readWorksheetFromFile("E:/YEAR 4/Code/APS490RBCCM/Intraday_Test_Data1.xls",
sheet=1,
startRow = 3,
check.names = FALSE
)
mylist = c()
mylist[1] = 1
for(i in 1:length(file)){
if(is.na(file[,i])) {
mylist[length(mylist)+1] = i
}}
tick = file[, mylist[1]:   (mylist[2] - 1)]
bid  = file[,(mylist[2]+1):(mylist[3] - 1)]
ask  = file[,(mylist[3]+1):length(file)]
tick$OPEN[1,1]
tick$OPEN[1]
tick$OPEN[3]
tick$Date[1]
tick$Date[end]
tick$Date[length(tick$Date)]
library(XLConnect)
file <- readWorksheetFromFile("E:/YEAR 4/Code/APS490RBCCM/testdata.xls",
sheet=1,
startRow = 3,
check.names = FALSE
)
mylist = c()
mylist[1] = 1
for(i in 1:length(file)){
if(is.na(file[,i])) {
mylist[length(mylist)+1] = i
}}
tick = file[, mylist[1]:   (mylist[2] - 1)]
bid  = file[,(mylist[2]+1):(mylist[3] - 1)]
ask  = file[,(mylist[3]+1):length(file)]
tick$HIGH
rm(list=ls())
# output <- function(tradesbook, positionbook, ask_prices, bid_prices, market_data){
### TESTED
tradesbook <- global_tables$tradesbook
# manually add a row into the tradebook since the naive strategy doesn't empty inventory at end of session
new_row <- c(1444071660, "AAPL", 1, 1, 110.92, "Close", .15)
tradesbook <- rbind(tradesbook, new_row)
positionbook <- global_tables$positionbook
### TESTED
### TESTED
# manipulate positionbook to make it a dataframe (it is received as a list)
positionbook <- do.call(rbind, positionbook)
positionbook <- cbind(Timestamp = rownames(positionbook), positionbook)
rownames(positionbook) <- 1:nrow(positionbook)
positionbook$Timestamp <- sapply(strsplit(as.character(positionbook$Timestamp),".",fixed = TRUE), "[[", 1)
ask_prices <- global_tables$ask_price
bid_prices <- global_tables$bid_price
### TESTED
### TESTED
# find the unique stocks that have been traded over the duration
stock_list <- unique(as.vector(tradesbook$Symbol))
# Set up the data frame which will store the cumulative pnl values for each stock and portfolio
Pnl_df <- data.frame(Symbol=character(), DateTime=as.Date(character()), BidAskPrice=character(),
BookValue=integer(), Side=integer(), Quantity = integer(),
Open.Close = character(), PnLStock = integer(), Cash = integer(),
Portfolio = integer(), PnLPortfolio = integer())
source('constants.r')
setwd("E:/YEAR 4/Code/APS490RBCCM")
source('constants.r')
source('data_cleaning.r')
init_cash = 100000
#global_variables: position matrices, trade matrices, ourdata, order book
#order format: msgtype, symbol, price, quantity, side, ordtype, orderID, time
#execution message format: orderID, Execstatus, symbol, quantity, avg price, side, time
#Execstatus can be the following: filled, replaced, cancelled, replacereject?, cancelreject
#order book format: orderID, time, symbol, price, quantity, side, ordtype
#trade matrix format: time, symbol, side, quantity, price, open/close, pnl
#position matrix: time, asset, #of shares, book value, market value,
datafile_name = "../data/TSXdatafile.xls"
global_tables = new.env()
global_tables[[Con_GlobalVarName_LOB]]<- data.frame(matrix(0, 0, length(orderbook_spec)))
colnames(global_tables[[Con_GlobalVarName_LOB]]) <- orderbook_spec
#the position book is a list of data frames
init_pos <- data.frame(matrix(0, 1, length(positionbook_spec)))
colnames(init_pos) <- positionbook_spec
init_pos[,Con_FieldName_Sym] = Con_Sym_Cash
init_pos[,c(Con_FieldName_Qty, Con_FieldName_BookVal, Con_FieldName_MktVal)] = init_cash
global_tables[[Con_GlobalVarName_PositionBook]] <- list(init_pos)
names(global_tables[[Con_GlobalVarName_PositionBook]])[1] = 0
global_tables[[Con_GlobalVarName_TradesBook]] <- data.frame(matrix(0, 0, length(tradesbook_spec)))
colnames(global_tables[[Con_GlobalVarName_TradesBook]]) <- tradesbook_spec
global_tables[[Con_GlobalVarName_ListDates]] <- list(vector())
import_data(global_tables)
source('E:/YEAR 4/Code/APS490RBCCM/strategy_ipr.R')
strategy_impliedpricerisk(c("tick", "ask", "bid"), global_tables, 1950, 1950, 1950)
source('E:/YEAR 4/Code/APS490RBCCM/strategy_ipr.R')
strategy_impliedpricerisk(c("tick", "ask", "bid"), global_tables, 1950, 1950, 1950)
debugSource('E:/YEAR 4/Code/APS490RBCCM/strategy_ipr.R')
strategy_impliedpricerisk(c("tick", "ask", "bid"), global_tables, 1950, 1950, 1950)
debugSource('E:/YEAR 4/Code/APS490RBCCM/strategy_ipr.R')
strategy_impliedpricerisk(c("tick", "ask", "bid"), global_tables, 1950, 1950, 1950)
actiontime
totaltime
env[[stock_data]][["Date"]]
strategy_impliedpricerisk(c("AC", "BNS", "BMO"), global_tables, 1950, 1950, 1950)
getquotes<-function(env,symbol,time){
# return (Nstocks * rows)
# if no quote then return empty
# aftermarket hour, 930-4 then return empty
#===========================================
# this function returns an updated mkt_quote table
mkt_quote = data.frame(matrix(NA, length(symbol), length(mkt_quote_spec)))
colnames(mkt_quote) <- mkt_quote_spec
time_930 <- get_time_since_open(as.POSIXct("2000-01-01 09:30:00", tz = "EST"))
time_931 <- get_time_since_open(as.POSIXct("2000-01-01 09:31:00", tz = "EST"))
time_1559 <- get_time_since_open(as.POSIXct("2000-01-01 15:59:00", tz = "EST"))
time_1600 <- get_time_since_open(as.POSIXct("2000-01-01 16:00:00", tz = "EST"))
for (i in 1:length(symbol)){
#time <- "2000-01-01 09:30:00 EST"
datatable_name_tick <- paste(symbol[i], Con_Data_Tick_Suffix, sep = "")
datatable_name_bid <- paste(symbol[i], Con_Data_Bid_Suffix, sep = "")
datatable_name_ask <- paste(symbol[i], Con_Data_Ask_Suffix, sep = "")
time_since_open <- get_time_since_open(as.POSIXct(time))
if (time_since_open == time_930){
# 9:30 then opening tick for 5 prices, val/vol/tick = 0
j <- (1:nrow(env[[datatable_name_tick]]))[env[[datatable_name_tick]][[Con_Data_ColName_Date]] == time]
if (length(j) == 0){
return (mkt_quote)
}
else{
mkt_quote[i, Con_FieldName_Sym] <- symbol[i]
mkt_quote[i, Con_FieldName_CurrentBid] <- env[[datatable_name_tick]][[Con_Data_ColName_Open]][j]
mkt_quote[i, Con_FieldName_CurrentAsk] <- env[[datatable_name_tick]][[Con_Data_ColName_Open]][j]
mkt_quote[i, Con_FieldName_CurrentTick] <- env[[datatable_name_tick]][[Con_Data_ColName_Open]][j]
mkt_quote[i, Con_FieldName_LastHighestBid] <- env[[datatable_name_tick]][[Con_Data_ColName_Open]][j]
mkt_quote[i, Con_FieldName_LastLowestAsk] <- env[[datatable_name_tick]][[Con_Data_ColName_Open]][j]
mkt_quote[i, Con_Data_ColName_LastNumTicks] <- 0
mkt_quote[i, Con_Data_ColName_LastVolume] <- 0
mkt_quote[i, Con_Data_ColName_LastValue] <- 0
}
}
else if (time_since_open == time_1600){
# 15:59 close tick,val/vol/tick
j <- (1:nrow(env[[datatable_name_tick]]))[env[[datatable_name_tick]][[Con_Data_ColName_Date]] == time - 60]
if (length(j) == 0){
return (mkt_quote)
}
else{
mkt_quote[i, Con_FieldName_Sym] <- symbol[i]
mkt_quote[i, Con_FieldName_CurrentBid] <- env[[datatable_name_tick]][[Con_Data_ColName_LastPrice]][j]
mkt_quote[i, Con_FieldName_CurrentAsk] <- env[[datatable_name_tick]][[Con_Data_ColName_LastPrice]][j]
mkt_quote[i, Con_FieldName_CurrentTick] <- env[[datatable_name_tick]][[Con_Data_ColName_LastPrice]][j]
mkt_quote[i, Con_FieldName_LastHighestBid] <- env[[datatable_name_bid]][[Con_Data_ColName_High]][j]
mkt_quote[i, Con_FieldName_LastLowestAsk] <- env[[datatable_name_ask]][[Con_Data_ColName_Low]][j]
mkt_quote[i, Con_Data_ColName_LastNumTicks] <- env[[datatable_name_tick]][[Con_Data_ColName_NumTicks]][j]
mkt_quote[i, Con_Data_ColName_LastVolume] <- env[[datatable_name_tick]][[Con_Data_ColName_Volume]][j]
mkt_quote[i, Con_Data_ColName_LastValue] <- env[[datatable_name_tick]][[Con_Data_ColName_Value]][j]
}
}
else if (time_since_open >= time_931 & time_since_open <= time_1559){
j <- (1:nrow(env[[datatable_name_tick]]))[env[[datatable_name_tick]][[Con_Data_ColName_Date]] == time]
if (length(j) == 0){
return (mkt_quote)
}
else{
mkt_quote[i, Con_FieldName_Sym] <- symbol[i]
mkt_quote[i, Con_FieldName_CurrentBid] <- env[[datatable_name_bid]][[Con_Data_ColName_Open]][j]
mkt_quote[i, Con_FieldName_CurrentAsk] <- env[[datatable_name_ask]][[Con_Data_ColName_Open]][j]
mkt_quote[i, Con_FieldName_CurrentTick] <- env[[datatable_name_tick]][[Con_Data_ColName_Open]][j]
mkt_quote[i, Con_FieldName_LastHighestBid] <- env[[datatable_name_bid]][[Con_Data_ColName_High]][j-1]
mkt_quote[i, Con_FieldName_LastLowestAsk] <- env[[datatable_name_ask]][[Con_Data_ColName_Low]][j-1]
mkt_quote[i, Con_Data_ColName_LastNumTicks] <- env[[datatable_name_tick]][[Con_Data_ColName_NumTicks]][j-1]
mkt_quote[i, Con_Data_ColName_LastVolume] <- env[[datatable_name_tick]][[Con_Data_ColName_Volume]][j-1]
mkt_quote[i, Con_Data_ColName_LastValue] <- env[[datatable_name_tick]][[Con_Data_ColName_Value]][j-1]
}
}
else{
}
}
# this function returns an updated mkt_quote table
return (mkt_quote)
}
#untested
update_pendingorderbook <- function (env, timestamp, symbol){
#orderbook is a referene (pointer in an environment), and changes are meant to be permanent
#taking in orderbook as argument and returns a list containing execution messages
#for the purpose of this back testing order book will only contain pending limit orders
#env <-global_tables
#symbol <- "BNS"
#timestamp <- "2015-05-13 09:41:00 EDT"
orderbook <- env[[Con_GlobalVarName_LOB]]
quotes <- getquotes(env, symbol, timestamp)
symbols_on_book <- orderbook[, Con_FieldName_Sym]
dim(symbols_on_book) <- length(symbols_on_book)
ask <- apply(symbols_on_book, 1, function (sym) {return (quotes[quotes[,Con_FieldName_Sym] == sym, Con_FieldName_LastLowestAsk])})
bid <- apply(symbols_on_book, 1, function (sym) {return (quotes[quotes[,Con_FieldName_Sym] == sym, Con_FieldName_LastHighestBid])})
ready_indices <- (orderbook[,Con_FieldName_Price] >= ask & orderbook[,Con_FieldName_Side] == Con_Side_Buy) |(orderbook[,Con_FieldName_Price] <= bid & orderbook[,Con_FieldName_Side] == Con_Side_Sell)
ready_orders <- orderbook[ready_indices,]
executed_price <- orderbook[ready_indices, Con_FieldName_Price]
env[[Con_GlobalVarName_LOB]] <- orderbook[!ready_indices,]
exec_msgs <- generate_fill_msgs(ready_orders, executed_price, timestamp)
update_trades_pnl_tables(exec_msgs, env, timestamp)
return (exec_msgs)
}
update_trades_pnl_tables<- function (fill_msgs, env, timestamp){
#posTable and tradesTable are references and changes are permanent
#takes in a list of execution messages and change the two tables, returns nothing
#make sure every message is fill for sure
fill_msgs <- fill_msgs[fill_msgs[,Con_FieldName_ExecStatus] == Con_ExecStatus_filled,]
if (nrow(fill_msgs) == 0){
return()
}
#update the position tables & trades table
tradesbook_name <- Con_GlobalVarName_TradesBook
positionbook <- env[[Con_GlobalVarName_PositionBook]]
last_pos <- positionbook[[length(positionbook)]]
new_pos <- last_pos
previous_cash <- new_pos[new_pos[, Con_FieldName_Sym]== Con_Sym_Cash, Con_FieldName_Qty]
cash_change <- 0
for (i in 1:nrow(fill_msgs)){
fill_sym <- fill_msgs[i, Con_FieldName_Sym]
fill_side <- fill_msgs[i, Con_FieldName_Side]
fill_qty <- fill_msgs[i, Con_FieldName_Qty]
fill_price <- fill_msgs[i, Con_FieldName_AvgPrice]
cash_change <- cash_change + (fill_side == Con_Side_Sell) * fill_qty * fill_price - (fill_side == Con_Side_Buy) * fill_qty * fill_price
#cat("hi", length((1:nrow(new_pos))[new_pos[,Con_FieldName_Sym] == fill_sym]), "\n")
if (length((1:nrow(new_pos))[new_pos[,Con_FieldName_Sym] == fill_sym]) == 0){
#no positions exist for this symbol yet
new_line_index <- nrow(new_pos) + 1
new_pos[new_line_index, Con_FieldName_Sym] <- fill_sym
new_pos[new_line_index, Con_FieldName_Qty] <- ((fill_side == Con_Side_Buy) * fill_qty
- (fill_side == Con_Side_Sell) * fill_qty)
new_pos[new_line_index, Con_FieldName_BookVal] <- new_pos[new_line_index, Con_FieldName_Qty] * fill_price
new_pos[new_line_index, Con_FieldName_MktVal] <- new_pos[new_line_index, Con_FieldName_BookVal]
#update the trades table
insert_into_tradesbook(env, tradesbook_name, time = timestamp, sym = fill_sym,
side = fill_side, qty = fill_qty, price = fill_price,
openclose = Con_OpenClose_Open, pnl = NA)
}
else{
#positions exist for this symbol
index <- (1:nrow(new_pos))[new_pos[,Con_FieldName_Sym] == fill_msgs[i, Con_FieldName_Sym]][1]
orig_quantity <- new_pos[index, Con_FieldName_Qty]
orig_bkval <- new_pos[index, Con_FieldName_BookVal]
new_pos[index, Con_FieldName_Qty] <- (orig_quantity +
(fill_side == Con_Side_Buy) * fill_qty
- (fill_side == Con_Side_Sell) * fill_qty)
new_pos[index, Con_FieldName_MktVal] <- new_pos[index, Con_FieldName_Qty] * fill_price
new_pos[index, Con_FieldName_BookVal] <- (new_pos[index, Con_FieldName_BookVal] +
((fill_side == Con_Side_Buy) * fill_qty
- (fill_side == Con_Side_Sell) * fill_qty) * fill_price)
oc <- Con_OpenClose_Open
pnl <- NA
quantity <- fill_qty
if ((orig_quantity < 0 & fill_side == Con_Side_Buy) | (orig_quantity > 0 & fill_side == Con_Side_Sell)){
#the execution offsets a closes some positions
if ((new_pos[index, Con_FieldName_Qty] > 0 & fill_side == Con_Side_Buy) |
(new_pos[index, Con_FieldName_Qty] < 0 & fill_side == Con_Side_Sell)){
#if the execution opens up an position as well
opposite_pos_qty <- new_pos[index, Con_FieldName_Qty]
oc = Con_OpenClose_Close
pnl = -(orig_quantity) * (orig_bkval/orig_quantity - fill_price)
new_pos[index, Con_FieldName_BookVal] <- new_pos[index, Con_FieldName_BookVal] + pnl
quantity <- abs(orig_quantity)
#cat(quantity, " ", orig_bkval, " ", orig_quantity, " ", orig_bkval/orig_quantity, " ", fill_price, " ", pnl, "\n")
insert_into_tradesbook(env, tradesbook_name, time = timestamp, sym = fill_sym,
side = fill_side, qty = opposite_pos_qty, price = fill_price,
openclose = Con_OpenClose_Open, pnl = NA)
}
else{
oc = Con_OpenClose_Close
pnl = (((fill_side == Con_Side_Buy) * fill_qty - (fill_side == Con_Side_Sell) * fill_qty)
* (orig_bkval/orig_quantity - fill_price))
new_pos[index, Con_FieldName_BookVal] <- new_pos[index, Con_FieldName_BookVal] + pnl
#cat(fill_qty, " ", orig_mktval, " ", orig_quantity, " ", orig_mktval/orig_quantity, " ", fill_price, " ", pnl, "\n")
}
}
insert_into_tradesbook(env, tradesbook_name, time = timestamp, sym = fill_sym,
side = fill_side, qty = quantity, price = fill_price,
openclose = oc, pnl = pnl)
}
}
#if position is flat remove this line
new_pos <- new_pos[!new_pos[,Con_FieldName_Qty] == 0,]
new_pos[new_pos[, Con_FieldName_Sym]== Con_Sym_Cash, c(Con_FieldName_Qty, Con_FieldName_BookVal, Con_FieldName_MktVal)] <- previous_cash + cash_change
positionbook[[length(positionbook) + 1]] <- new_pos
names(positionbook)[length(positionbook)] <- timestamp
env[[Con_GlobalVarName_PositionBook]] <- positionbook
}
#untested new orders, cancel and replace not implemented
handle_orders <- function (orders, symbol, env, timestamp){
#orderbook is a referene (pointer in an environment), and changes are meant to be permanent
#handles all orders (new, replace, cancels) and update the order book approriately
#returns execution messages
quotes <- getquotes(env, symbol, timestamp)
new_orders <- orders[orders[,Con_FieldName_MsgType] == Con_MsgType_New,]
replace_orders <- orders[orders[,Con_FieldName_MsgType] == Con_MsgType_Replace,]
cancel_orders <- orders[orders[,Con_FieldName_MsgType] == Con_MsgType_Cancel,]
mkt_new <- new_orders[new_orders[,Con_FieldName_OrdType] == Con_OrdType_Mkt, ]
mkt_order_symbols <- mkt_new[, Con_FieldName_Sym]
dim(mkt_order_symbols) <- length(mkt_order_symbols)
mkt_ask <- apply(mkt_order_symbols, 1, function (sym) {return (quotes[quotes[,Con_FieldName_Sym] == sym, Con_FieldName_CurrentAsk])})
mkt_bid <- apply(mkt_order_symbols, 1, function (sym) {return (quotes[quotes[,Con_FieldName_Sym] == sym, Con_FieldName_CurrentBid])})
mkt_exec_prices <- (mkt_new[, Con_FieldName_Side] == Con_Side_Buy ) * mkt_ask +
(mkt_new[, Con_FieldName_Side] == Con_Side_Sell ) * mkt_bid
limit_new <- new_orders[new_orders[,Con_FieldName_OrdType] == Con_OrdType_Limit, ]
lmt_order_symbols <- limit_new[, Con_FieldName_Sym]
dim(lmt_order_symbols) <- length(lmt_order_symbols)
lmt_ask <- apply(lmt_order_symbols, 1, function (sym) {return (quotes[quotes[,Con_FieldName_Sym] == sym, Con_FieldName_CurrentAsk])})
lmt_bid <- apply(lmt_order_symbols, 1, function (sym) {return (quotes[quotes[,Con_FieldName_Sym] == sym, Con_FieldName_CurrentBid])})
mkt_lmt_orders_indices <- (limit_new[,Con_FieldName_Price] >= lmt_ask & limit_new[,Con_FieldName_Side] == Con_Side_Buy) |(limit_new[,Con_FieldName_Price] <= lmt_bid & limit_new[,Con_FieldName_Side] == Con_Side_Sell)
mkt_lmt_orders <- limit_new[mkt_lmt_orders_indices,]
mkt_lmt_ask <- lmt_ask[mkt_lmt_orders_indices]
mkt_lmt_bid <- lmt_bid[mkt_lmt_orders_indices]
mkt_lmt_prices <- (mkt_lmt_orders[, Con_FieldName_Side] == Con_Side_Buy ) * mkt_lmt_ask +
(mkt_lmt_orders[, Con_FieldName_Side] == Con_Side_Sell ) * mkt_lmt_bid
insert_into_orderbook(limit_new, env, Con_GlobalVarName_LOB)
exec_replace <- handle_replaces(replace_orders, orderbook, timestamp)
exec_cancel <- handle_cancels(cancel_orders, orderbook, timestamp)
#fill must come after replace and cancel has been handled
exec_fill <- rbind(generate_fill_msgs(mkt_new, mkt_exec_prices, timestamp), generate_fill_msgs(mkt_lmt_orders, mkt_lmt_prices, timestamp))
update_trades_pnl_tables(exec_fill, env, timestamp)
return(rbind(exec_replace, exec_cancel, exec_fill))
}
#tested
generate_fill_msgs <- function(ready_orders_list, exec_price, timestamp){
fill_msgs <- data.frame(matrix(0, nrow(ready_orders_list), length(exec_msg_spec)))
colnames(fill_msgs) <- exec_msg_spec
fill_msgs[, Con_FieldName_OrdID] <- ready_orders_list[, Con_FieldName_OrdID]
fill_msgs[, Con_FieldName_ExecStatus] <- rep(Con_ExecStatus_filled, nrow(ready_orders_list))
fill_msgs[, Con_FieldName_Sym] <- ready_orders_list[, Con_FieldName_Sym]
fill_msgs[, Con_FieldName_Qty] <- ready_orders_list[, Con_FieldName_Qty]
fill_msgs[, Con_FieldName_AvgPrice] <- exec_price
fill_msgs[, Con_FieldName_Side] <- ready_orders_list[, Con_FieldName_Side]
fill_msgs[, Con_FieldName_Time] <- rep(timestamp, nrow(ready_orders_list))
return (fill_msgs)
}
#tested
insert_into_orderbook <-function(limit_orders, env, orderbook_name){
#orderbook is a referene (pointer in an environment), and changes are meant to be permanent
#insert limit orders into orderbook, return nothing
new_entries <- data.frame((matrix(0, nrow(limit_orders), length(orderbook_spec))))
colnames(new_entries) <- orderbook_spec
new_entries[, Con_FieldName_OrdID] <- limit_orders[, Con_FieldName_OrdID]
new_entries[, Con_FieldName_Time] <- limit_orders[, Con_FieldName_Time]
new_entries[, Con_FieldName_Sym] <- limit_orders[, Con_FieldName_Sym]
new_entries[, Con_FieldName_Price] <- limit_orders[, Con_FieldName_Price]
new_entries[, Con_FieldName_Qty] <- limit_orders[, Con_FieldName_Qty]
new_entries[, Con_FieldName_Side] <- limit_orders[, Con_FieldName_Side]
new_entries[, Con_FieldName_OrdType] <- limit_orders[, Con_FieldName_OrdType]
env[[orderbook_name]] <- rbind(env[[orderbook_name]], new_entries)
}
#tested
insert_into_tradesbook <- function(env, tradesbook_name, time, sym, qty, side, price, openclose, pnl){
new_line_index <- nrow(env[[tradesbook_name]]) + 1
env[[tradesbook_name]][new_line_index, Con_FieldName_Time] <- time
env[[tradesbook_name]][new_line_index, Con_FieldName_Sym] <- sym
env[[tradesbook_name]][new_line_index, Con_FieldName_Side] <- side
env[[tradesbook_name]][new_line_index, Con_FieldName_Qty] <- qty
env[[tradesbook_name]][new_line_index, Con_FieldName_Price] <- price
env[[tradesbook_name]][new_line_index, Con_FieldName_OpenClose] <- openclose
env[[tradesbook_name]][new_line_index, Con_FieldName_Pnl] <- pnl
}
handle_cancels <- function(cancelorders, orderbook, timestamp){
#returns execution messages
#cat(cancelorders)
}
handle_replaces <- function(replaceorders, orderbook, timestamp){
#returns execution messages
}
get_time_since_open <- function(timestamp){
if (strftime(timestamp, format = "%Z") == "EDT")
return ((as.numeric(timestamp) %% 86400) - 48600)
else
return ((as.numeric(timestamp) %% 86400) - 52200)
}
# ################################################
<<<<<<< HEAD
strategy_impliedpricerisk(c("AC", "BNS", "BMO"), global_tables, 1950, 1950, 1950)
strategy_impliedpricerisk(c("AC", "BNS", "BMO"), global_tables, 1950, 1950, 1950)
global_table$positionbook
=======
head(global_tables[["ABX_ask"]][1,1])
head(global_tables[["ABX_ask"]][,1])
head(global_tables[["ABX_ask"]])
head(global_tables[["ABX_bid"]])
head(global_tables[["ABX_tick"]])
global_tables[["ABX_tick"]][1,1]-global_tables[["ABX_tick"]][2,1]
global_tables[["ABX_tick"]][1,1]
strptime(global_tables[["ABX_tick"]][1,1], "%Y-%m-%d %H:%M:%S")
getwd()
getwd()
rm(list = ls())
source('constants.r')
source('backtest_lib.r')
source('data_cleaning.r')
source('strategy_hmm.r')
library(XLConnect)
#library(knitr)
# notes 2015-11-20
#1. ETL (cleaning, organizing section), factor in for missing data, outliers, etc.
# -> think of the opportunistic time intervals to trade (don't decide arbritarily, decide based on
# intelligence)
# -> separate the strategy from the market module in the flow chart
# -> market sends back fills and acknowledgements (assume we don't need this)
# -> strategy will act only upon "fill" (may not need to do this) and "timer"
=======
>>>>>>> Stashed changes
# -> market reacts to order,replace,cancel and market data
# -> change active and passive to fill and timer
# -> highlight strategy with more detail
#knitr::spin
init_cash = 100000
#global_variables: position matrices, trade matrices, ourdata, order book
#order format: msgtype, symbol, price, quantity, side, ordtype, orderID, time
#execution message format: orderID, Execstatus, symbol, quantity, avg price, side, time
#Execstatus can be the following: filled, replaced, cancelled, replacereject?, cancelreject
#order book format: orderID, time, symbol, price, quantity, side, ordtype
#trade matrix format: time, symbol, side, quantity, price, open/close, pnl
#position matrix: time, asset, #of shares, book value, market value,
datafile_name = "../data/TSXdatafile.xls"
global_tables = new.env()
global_tables[[Con_GlobalVarName_LOB]]<- data.frame(matrix(0, 0, length(orderbook_spec)))
colnames(global_tables[[Con_GlobalVarName_LOB]]) <- orderbook_spec
#the position book is a list of data frames
init_pos <- data.frame(matrix(0, 1, length(positionbook_spec)))
colnames(init_pos) <- positionbook_spec
init_pos[,Con_FieldName_Sym] = Con_Sym_Cash
init_pos[,c(Con_FieldName_Qty, Con_FieldName_BookVal, Con_FieldName_MktVal)] = init_cash
global_tables[[Con_GlobalVarName_PositionBook]] <- list(init_pos)
names(global_tables[[Con_GlobalVarName_PositionBook]])[1] = 0
global_tables[[Con_GlobalVarName_TradesBook]] <- data.frame(matrix(0, 0, length(tradesbook_spec)))
colnames(global_tables[[Con_GlobalVarName_TradesBook]]) <- tradesbook_spec
global_tables[[Con_GlobalVarName_ListDates]] <- list(vector())
import_data(global_tables)
<<<<<<< HEAD
source('E:/YEAR 4/Code/APS490RBCCM/strategy_ipr.R')
source('E:/YEAR 4/Code/APS490RBCCM/strategy_ipr.R')
strategy_impliedpricerisk(c("AC", "BNS", "BMO"), global_tables, 1560, 1560)
>>>>>>> origin/master
global_tables$positionbook
results <- data.frame()
for (i in 1:length(global_tables$positionbook)){
results <- rbind(results, portfoliovalue = sum(global_tables$positionbook[[i]]["MarketValue"]))
}
results
source('E:/YEAR 4/Code/APS490RBCCM/strategy_ipr.R')
strategy_impliedpricerisk(c("AC", "BNS", "BMO"), global_tables, 1950, 1950, 1950)
source('E:/YEAR 4/Code/APS490RBCCM/strategy_ipr.R')
debugSource('E:/YEAR 4/Code/APS490RBCCM/strategy_ipr.R')
strategy_impliedpricerisk(c("AC", "BNS", "BMO"), global_tables, 1950, 1950, 1950)
i
jump
start_row
i
start_row
iprframe
debugSource('E:/YEAR 4/Code/APS490RBCCM/strategy_ipr.R')
strategy_impliedpricerisk(c("AC", "BNS", "BMO"), global_tables, 1950, 1950, 1950)
i
start_row
returns
returns
source('E:/YEAR 4/Code/APS490RBCCM/strategy_ipr.R')
<<<<<<< HEAD
source('E:/YEAR 4/Code/APS490RBCCM/strategy_ipr.R')
strategy_impliedpricerisk(c("AC", "BNS", "BMO"), global_tables, 1950, 1950, 1950)
init_cash = 100000
#global_variables: position matrices, trade matrices, ourdata, order book
#order format: msgtype, symbol, price, quantity, side, ordtype, orderID, time
#execution message format: orderID, Execstatus, symbol, quantity, avg price, side, time
#Execstatus can be the following: filled, replaced, cancelled, replacereject?, cancelreject
#order book format: orderID, time, symbol, price, quantity, side, ordtype
#trade matrix format: time, symbol, side, quantity, price, open/close, pnl
#position matrix: time, asset, #of shares, book value, market value,
datafile_name = "../data/TSXdatafile.xls"
global_tables = new.env()
=======
strategy_impliedpricerisk(c("AC", "BNS", "BMO"), global_tables, 1560, 1560)
global_tables$positionbook
source('E:/YEAR 4/Code/APS490RBCCM/obtainthreshold.r')
source('E:/YEAR 4/Code/APS490RBCCM/obtainthreshold.r')
debugSource('E:/YEAR 4/Code/APS490RBCCM/obtainthreshold.r')
debugSource('E:/YEAR 4/Code/APS490RBCCM/strategy_ipr.R')
strategy_impliedpricerisk(c("AC", "BNS", "BMO"), global_tables, 1560, 1560)
debugSource('E:/YEAR 4/Code/APS490RBCCM/obtainthreshold.r')
debugSource('E:/YEAR 4/Code/APS490RBCCM/strategy_ipr.R')
strategy_impliedpricerisk(c("AC", "BNS", "BMO"), global_tables, 1560, 1560)
debugSource('E:/YEAR 4/Code/APS490RBCCM/obtainthreshold.r')
debugSource('E:/YEAR 4/Code/APS490RBCCM/strategy_ipr.R')
strategy_impliedpricerisk(c("AC", "BNS", "BMO"), global_tables, 1560, 1560)
obtainthreshold(global_tables, c("AC", "BNS", "BMO"), 1561, 1560, 13)
debugSource('E:/YEAR 4/Code/APS490RBCCM/obtainthreshold.r')
obtainthreshold(global_tables, c("AC", "BNS", "BMO"), 1561, 1560, 13)
increment
sum(returns["return1"])
debugSource('E:/YEAR 4/Code/APS490RBCCM/obtainthreshold.r')
obtainthreshold(global_tables, c("AC", "BNS", "BMO"), 1561, 1560, 13)
increment
threshold
increment
increment
increment
threshold\
threshold
increment
threshold
increment
increment
sum(returns["return1"])
increment
source('E:/YEAR 4/Code/APS490RBCCM/obtainthreshold.r')
obtainthreshold(global_tables, c("AC", "BNS", "BMO"), 1561, 1560, 13)
source('E:/YEAR 4/Code/APS490RBCCM/obtainthreshold.r')
obtainthreshold(global_tables, c("AC", "BNS", "BMO"), 1561, 1560, 13)
debugSource('E:/YEAR 4/Code/APS490RBCCM/strategy_ipr.R')
strategy_impliedpricerisk(c("AC", "BNS", "BMO"), global_tables, 1560, 1560)
source('E:/YEAR 4/Code/APS490RBCCM/obtainthreshold.r')
debugSource('E:/YEAR 4/Code/APS490RBCCM/strategy_ipr.R')
source('E:/YEAR 4/Code/APS490RBCCM/obtainthreshold.r')
strategy_impliedpricerisk(c("AC", "BNS", "BMO"), global_tables, 1560, 1560)
=======
# output <- output(global_tables$tradesbook, global_tables$positionbook, global_tables$ask_price,
#                   global_tables$bid_price, globa_tables$market_data)
system.time({predic_accuracy <- test_HMMM(global_tables, 'BNS', 5, 3)})
comparison <- predictions[,2:Tnum] == actual_directions[1:nrow(predictions),2:Tnum]
result<-sum(comparison[!is.na(comparison)]) / (nrow(comparison) * ncol(comparison))
result
global_tables$positionbook
mu
>>>>>>> origin/master
global_tables[[Con_GlobalVarName_LOB]]<- data.frame(matrix(0, 0, length(orderbook_spec)))
colnames(global_tables[[Con_GlobalVarName_LOB]]) <- orderbook_spec
#the position book is a list of data frames
init_pos <- data.frame(matrix(0, 1, length(positionbook_spec)))
colnames(init_pos) <- positionbook_spec
init_pos[,Con_FieldName_Sym] = Con_Sym_Cash
init_pos[,c(Con_FieldName_Qty, Con_FieldName_BookVal, Con_FieldName_MktVal)] = init_cash
global_tables[[Con_GlobalVarName_PositionBook]] <- list(init_pos)
names(global_tables[[Con_GlobalVarName_PositionBook]])[1] = 0
global_tables[[Con_GlobalVarName_TradesBook]] <- data.frame(matrix(0, 0, length(tradesbook_spec)))
colnames(global_tables[[Con_GlobalVarName_TradesBook]]) <- tradesbook_spec
global_tables[[Con_GlobalVarName_ListDates]] <- list(vector())
<<<<<<< HEAD
import_data(global_tables)
source('E:/YEAR 4/Code/APS490RBCCM/data_cleaning.R')
source('E:/YEAR 4/Code/APS490RBCCM/data_cleaning.R')
=======
test_HMMM(global_tables, 'BMO', 5, 3)
comparison <- predictions[,2:Tnum] == actual_directions[1:nrow(predictions),2:Tnum]
result<-sum(comparison[!is.na(comparison)]) / (nrow(comparison) * ncol(comparison))
result
global_tables$positionbook
mu
cov_mat
source('hmm_v2.r')
source('constants.r')
source('backtest_lib.r')
Boxcoxlambda_p_absolute = 0.05
Boxcoxlambda_p_increments = 0.04
Boxcoxlambda_interval_volume = 10
test_HMMM <- function (env, symbol, time_interval, num_states){
#     env <- global_tables
#     symbol = "BNS"
#     time_interval = 5
#     num_states = 4
datatable_name <- paste(symbol, Con_Data_Tick_Suffix, sep = "")
timestamp <- env[[datatable_name]][[Con_Data_ColName_Date]]
value <- env[[datatable_name]][[Con_Data_ColName_Value]]
volume <- env[[datatable_name]][[Con_Data_ColName_Volume]]
volatility <- env[[datatable_name]][[Con_Data_ColName_Value]]
#timestamp converted into integer represents seconds
#9:30 EDT mod 86400 = 48600, 9:30 EST mod 86400 = 48600+ 3600
#trading day is 23400s long
#split the data into days
#assume there is always data at 15:59
cat('Retrieving data \n')
time_since_open <- rep(0, length(timestamp))
num_of_minutes <- 390
for (i in 1: length(timestamp))
time_since_open[i] <- get_time_since_open(timestamp[i])
N <- sum(time_since_open == 0)
start_of_day_indices <- (1:length(timestamp))[time_since_open == 0]
num_of_lines_per_day <- start_of_day_indices[2] - start_of_day_indices[1]
value_by_day <- matrix(-1, nrow = N, ncol = num_of_minutes)
volume_by_day <- matrix(-1, nrow = N, ncol = num_of_minutes)
for (i in 1:N){
value_by_day[i,] = value[(i - 1) * num_of_lines_per_day + (1:num_of_minutes)]
volume_by_day[i,] = volume[(i - 1) * num_of_lines_per_day + (1:num_of_minutes)]
}
#time_interval = 5 #denote minutes
Tnum = 23400 / (time_interval * 60)
t_marker <- (time_interval * 60) * (1: Tnum)
VWAP <- matrix(0, nrow = N, ncol = Tnum + 1)
interval_volume = matrix(0, nrow = N, ncol = Tnum)
VWAP[,1] = env[[datatable_name]][[Con_Data_ColName_Open]][time_since_open == 0]
for (n in 1:N){
interval_volume[n,] <- colSums(matrix(volume_by_day[n,], nrow = time_interval, ncol = Tnum))
VWAP[n,2:(Tnum + 1)] <- colSums(matrix(value_by_day[n,], nrow = time_interval, ncol = Tnum)) / interval_volume[n,]
#correct NaN prices. This is caused by the interval volume being 0. In this case VWAP is the same
#as the last time period.
for(t in 2:(Tnum + 1)){
if (is.nan(VWAP[n, t])){
VWAP[n, t] = VWAP[n, t - 1]
}
}
}
Boxcoxlambda_interval_volume <- BoxCox.lambda(interval_volume, method=c("guerrero"),lower=-5, upper=5)
interval_volume<- BoxCox(interval_volume,lambda = Boxcoxlambda_interval_volume)
p_increments <- VWAP[,2:(Tnum + 1)] - VWAP[,1:Tnum]
Boxcoxlambda_p_increments <-BoxCox.lambda(p_increments,method=c("guerrero"),lower=-5, upper=5)
p_increments<- BoxCox(p_increments,lambda = Boxcoxlambda_p_increments)
p_absolute <- abs(VWAP[,2:(Tnum + 1)] - VWAP[,1:Tnum])
Boxcoxlambda_p_absolute <-BoxCox.lambda(p_absolute,method=c("guerrero"),lower=-5, upper=5)
p_absolute<- BoxCox(p_absolute,lambda = Boxcoxlambda_p_absolute)
N_training = 60
training_days <- c(1:N_training)
#qqnorm(as.vector(log(interval_volume[1:60,])))
p_increments_training <- p_increments[training_days,]
log_volume_training <- interval_volume[training_days,]
p_absolute_training <- p_absolute[training_days,]
num_var <- 3
training_data <- array(0, c(num_var, N_training, Tnum))
training_data[1,,] <- p_increments_training
training_data[2,,] <- log_volume_training
training_data[3,,] <- p_absolute_training
cat('get parameter estimates \n')
estimates <- get_params_estimates(training_data, num_var, num_states)
A <- matrix(data.matrix(estimates[["A"]]), nrow = num_states, ncol = num_states)
mu <- data.matrix(estimates[["mu"]])
cov_mat <- array(data.matrix(estimates[["cov_matrix"]]), c(num_var, num_var, num_states))
start_time <- as.POSIXct('2015-05-13 9:30:00 EDT')
end_time <- as.POSIXct('2015-09-18 15:59:00 EDT')
cat('run performance testing \n')
system.time({predictions <- performance_test(start_time, end_time, env, symbol, time_interval, num_states, num_var, A, mu, cov_mat)})
actual_directions <- matrix(NA, N, Tnum)
for (i in 1:N){
for (t in 1:Tnum){
if (p_increments[i,t] > 0){
actual_directions[i,t] = TRUE
}
else if(p_increments[i,t] < 0){
actual_directions[i,t] = FALSE
}
else{
}
}
}
comparison <- predictions[,2:Tnum] == actual_directions[1:nrow(predictions),2:Tnum]
return(sum(comparison[!is.na(comparison)]) / (nrow(comparison) * ncol(comparison)))
}
get_params_estimates <- function (training_data, num_var, num_states)
{
#training data is v X N X T matrix, where v is the number of state_variables, N is the number of time series, and T is the number of timesteps
remove_pct <- 0.05
Tnum <- dim(training_data)[3]
N <- dim(training_data)[2]
rows_to_remove <- rep(FALSE, N)
for (i in 1:num_var){
filter <- quantile(as.vector(training_data[i,,]), c(remove_pct * (1/Tnum), 1 - remove_pct * (1/Tnum)))
rows_to_remove <- rows_to_remove | (apply(training_data[i,,], 1, max) > filter[2]) |
(apply(training_data[i,,], 1, min) < filter[1])
}
data_aft_filter <- training_data[,!rows_to_remove,]
rand_size = dim(data_aft_filter)[2]
num_estimates <- 1
#order of state parameters: p_increments then log volume then p_absolute
#num_estimates is always the last dimension
A_estimates <- array(0, c(num_states, num_states, num_estimates))
mu_estimates <- array(0, c(num_var, num_states, num_estimates))
cov_mat_estimates <- array(0, c(num_var, num_var, num_states, num_estimates))
for (i in 1: num_estimates){
tr_indices <- sample(1:dim(data_aft_filter)[2], rand_size)
test_data = array(0, c(num_var, Tnum, rand_size))
for (j in 1:num_var){
test_data[j,,] <- t(data_aft_filter[j,tr_indices,])
}
estimate <- EM(test_data, num_states)
A_estimates[,,i] <- data.matrix(estimate[["A"]])
mu_estimates[,,i] <- data.matrix(estimate[["mu"]])
cov_mat_estimates[,,,i] <- array(data.matrix(estimate[["covariance matrix"]]), c(num_var, num_var, num_states))
}
rtn <- list(data.frame(A_estimates), data.frame(mu_estimates),
data.frame(cov_mat_estimates))
names(rtn) <- c('A', 'mu', 'cov_matrix')
return(rtn)
}
performance_test <- function(start_time, end_time, env, symbol, time_interval, num_states, num_var, A, mu, cov_mat){
#if for a symbol the quotes at a particular time is not available, then
#it is filled in by the data of the last available minute (e.g, if at 9:33 the data
#is missing, but at 9:32 it is available, then the quote at 9:32 is taken to be the same
# as the quote of 9:32)
#strategy: each minute trying to predict the price movement for next minute. If predicts going
#up then buy mkt order now and sell mkt order 1 interval later
#if predicts going down then sell order now and buy 1 interval later
current_time <- start_time
if (sum(is.na(getquotes(env, symbol, start_time))) != 0){
cat('Error: data not available at start time \n')
return
}
else if(sum(is.na(getquotes(env, symbol, end_time))) != 0){
cat('Error: data not available at end time \n')
return
}
Tnum <- 390 / time_interval
VWAP_prices <- vector()
interval_volume <- vector()
cumul_volume <- 0
cumul_value <- 0
cumul_volatility <- 0
orderID <- 0
predicted_price_direction <- NA
prediction_list <- matrix(NA, 0, Tnum)
p_increment_list <- matrix(NA, 0, Tnum)
p_absolute_list <- matrix(NA, 0, Tnum)
current_shares_to_trade <- 0
future_shares_to_trade <- 0
lot_size <- 100
eod_value <- vector()
execution_dates <- vector()
while (current_time <= end_time){
quotes <- getquotes(env, symbol, current_time)
if (sum(is.na(quotes)) != 0){
current_time <- current_time + 60
next
}
response <- update_pendingorderbook(env, current_time, symbol)
if (nrow(response)!=0){
passive_processing(response)
}
time_since_open <- get_time_since_open(current_time)
cumul_value <- cumul_value + quotes[,Con_Data_ColName_LastValue]
cumul_volume <- cumul_volume + quotes[,Con_Data_ColName_LastVolume]
cumul_volatility <- cumul_volatility + quotes[,Con_Data_ColName_LastValue]
if (time_since_open %% (time_interval* 60) == 0){
current_shares_to_trade <- future_shares_to_trade
future_shares_to_trade <- 0
#Active processing
if (time_since_open == 0){
VWAP_prices <- quotes[,Con_FieldName_CurrentTick]
interval_volume <- vector()
predicted_price_direction <- NA
cat('testing ', strftime(current_time, format = "%F"), '\n')
}
else if (time_since_open == 23400){
last_interval_VWAP_price <- cumul_value / cumul_volume
VWAP_prices <- append(VWAP_prices, last_interval_VWAP_price)
p_increment <- VWAP_prices[2:length(VWAP_prices)] - VWAP_prices[1:(length(VWAP_prices) - 1)]
p_absolute <- abs(VWAP_prices[2:length(VWAP_prices)] - VWAP_prices[1:(length(VWAP_prices) - 1)])
prediction_list <- rbind(prediction_list, predicted_price_direction)
p_increment_list <- rbind(p_increment_list, p_increment)
p_absolute_list <- rbind(p_absolute_list, p_absolute)
current_time = current_time + 60 * 60 * 16
}
else{
#price prediction
if (cumul_volume == 0){
last_interval_VWAP_price <- 0
}
else{
last_interval_VWAP_price <- cumul_value / cumul_volume
}
last_interval_volume <- cumul_volume
VWAP_prices <- append(VWAP_prices, last_interval_VWAP_price)
interval_volume <- append(interval_volume, last_interval_volume)
interval_volume <- BoxCox(interval_volume,lambda=Boxcoxlambda_interval_volume)
p_increment <- VWAP_prices[2:length(VWAP_prices)] - VWAP_prices[1:(length(VWAP_prices) - 1)]
p_absolute<- BoxCox(p_increment,lambda=Boxcoxlambda_p_increment)
p_absolute <- abs(VWAP_prices[2:length(VWAP_prices)] - VWAP_prices[1:(length(VWAP_prices) - 1)])
p_absolute<- BoxCox(p_absolute,lambda=Boxcoxlambda_p_absolute)
Tnum <- length(interval_volume)
test_data <- array(0, c(num_var, Tnum, 1))
test_data[1,,] <- p_increment
test_data[2,,] <- interval_volume
test_data[3,,] <- p_absolute
log_alpha <- calc_forward(num_states, 1, Tnum, num_var, A, mu, cov_mat, test_data)
last_period_alpha <- log_alpha[,length(interval_volume), 1]
alpha <- exp(last_period_alpha - max(last_period_alpha))
states_prob <- alpha / sum(alpha)
next_period_prob <- t(t(states_prob) %*% A)
expected_mu <- sum(next_period_prob * mu[1,]) #only calculating expected p_increment for next time period
if (current_time > as.POSIXct('2015-05-25 10:00:00 EDT')){
l1 <- 0
}
if (expected_mu > 0){
predicted_price_direction <- append(predicted_price_direction, TRUE)
current_shares_to_trade <- current_shares_to_trade + lot_size
future_shares_to_trade <- future_shares_to_trade - lot_size
}
else if (expected_mu < 0){
predicted_price_direction <- append(predicted_price_direction, FALSE)
current_shares_to_trade <- current_shares_to_trade -lot_size
future_shares_to_trade <- future_shares_to_trade + lot_size
}
else{
predicted_price_direction <- append(predicted_price_direction, NA)
}
}
if (current_shares_to_trade != 0){
side <- (current_shares_to_trade > 0) * Con_Side_Buy + (current_shares_to_trade < 0) * Con_Side_Sell
orders = data.frame(matrix(NA, 1, length(order_msg_spec)))
colnames(orders) <- order_msg_spec
orders[,Con_FieldName_MsgType] = Con_MsgType_New
orders[,Con_FieldName_OrdID] = orderID
orderID = orderID + 1
orders[,Con_FieldName_Sym] = symbol
orders[,Con_FieldName_Qty] = abs(current_shares_to_trade)
orders[,Con_FieldName_Side] = side
orders[,Con_FieldName_OrdType] = Con_OrdType_Mkt
response <- handle_orders(orders, symbol, env, current_time)
if (nrow(response)!=0){
passive_processing(response)
}
}
cumul_volume <- 0
cumul_value <- 0
cumul_volatility <- 0
}
if (time_since_open == 23340){
#liquidate current position at 15:59
positionbook <- env[[Con_GlobalVarName_PositionBook]]
last_pos <- positionbook[[length(positionbook)]]
if (nrow(last_pos) > 1){
outstanding_entries <- last_pos[last_pos[,Con_FieldName_Sym] != Con_Sym_Cash,]
clearing_order_side <- rep(0, nrow(outstanding_entries))
for (i in 1: nrow(outstanding_entries)){
if (outstanding_entries[i,Con_FieldName_Qty] < 0){
clearing_order_side[i] <- Con_Side_Buy
}
else{
clearing_order_side[i] <- Con_Side_Sell
}
}
orders = data.frame(matrix(NA, nrow(outstanding_entries), length(order_msg_spec)))
colnames(orders) <- order_msg_spec
orders[,Con_FieldName_MsgType] = Con_MsgType_New
orders[,Con_FieldName_OrdID] = orderID + 0:(nrow(outstanding_entries) - 1)
orderID = orderID + nrow(outstanding_entries)
orders[,Con_FieldName_Sym] = outstanding_entries[,Con_FieldName_Sym]
orders[,Con_FieldName_Qty] = abs(outstanding_entries[,Con_FieldName_Qty])
orders[,Con_FieldName_Side] = clearing_order_side
orders[,Con_FieldName_OrdType] = Con_OrdType_Mkt
response <- handle_orders(orders, symbol, env, current_time)
if (nrow(response)!=0){
passive_processing(response)
}
}
last_pos <- env[[Con_GlobalVarName_PositionBook]][[length(env[[Con_GlobalVarName_PositionBook]])]]
eod_value <- append(eod_value, last_pos[last_pos[,Con_FieldName_Sym] == Con_Sym_Cash, Con_FieldName_MktVal])
execution_dates <- append(execution_dates, current_time)
current_shares_to_trade <- 0
future_shares_to_trade <- 0
}
current_time <- current_time + 60
}
return(prediction_list)
}
passive_processing <- function(response){
}
source('constants.r')
source('backtest_lib.r')
source('data_cleaning.r')
source('strategy_hmm.r')
test_HMMM(global_tables, 'BMO', 5, 3)
source('strategy_hmm.r')
test_HMMM(global_tables, 'BMO', 5, 3)
source('strategy_hmm.r')
test_HMMM(global_tables, 'BMO', 5, 3)
predicted_price_direction
expected_mu
next_period_prob
states_prob
source('strategy_hmm.r')
source('strategy_hmm.r')
test_HMMM(global_tables, 'BMO', 5, 3)
source('strategy_hmm.r')
test_HMMM(global_tables, 'BMO', 5, 3)
expected_mu
predicted_price_direction
predicted_price_direction
current_shares_to_trade
future_shares_to_trade
if (expected_mu < 0){
predicted_price_direction <- append(predicted_price_direction, FALSE)
current_shares_to_trade <- current_shares_to_trade -lot_size
future_shares_to_trade <- future_shares_to_trade + lot_size
}
predicted_price_direction, FALSE
predicted_price_direction
predicted_price_direction
predicted_price_direction <- append(predicted_price_direction, FALSE)
predicted_price_direction
current_shares_to_trade <- current_shares_to_trade -lot_size
current_shares_to_trade
future_shares_to_trade <- future_shares_to_trade + lot_size
future_shares_to_trade
source('strategy_hmm.r')
test_HMMM(global_tables, 'BMO', 5, 3)
expected_mu
next_period_prob
mu
states_prob
alpha
last_period_alpha
interval_volume
interval_volume
timestamp()
##------ Wed Mar 16 10:17:43 2016 ------##
timestamp
current_time
p_increments
interval_volume
p_absolute
last_interval_volume
source('strategy_hmm.r')
test_HMMM(global_tables, 'BMO', 5, 3)
source('strategy_hmm.r')
test_HMMM(global_tables, 'BMO', 5, 3)
comparison
result<-sum(comparison[!is.na(comparison)]) / (nrow(comparison) * ncol(comparison))
result
global_tables$positionbook
result
source('strategy_hmm.r')
system.time({predic_accuracy <- test_HMMM(global_tables, 'BMO', 5, 3)})
predictions
actual_directions
comparison <- predictions[,2:Tnum] == actual_directions[1:nrow(predictions),2:Tnum]
comparison
result<-sum(comparison[!is.na(comparison)]) / (nrow(comparison) * ncol(comparison))
result
global_tables$tradesbook
head(global_tables$tradesbook)
global_tables$positionbook
source('strategy_hmm.r')
system.time({predic_accuracy <- test_HMMM(global_tables, 'BMO', 5, 3)})
rm(list = ls())
source('constants.r')
source('backtest_lib.r')
source('data_cleaning.r')
source('strategy_hmm.r')
library(XLConnect)
#library(knitr)
#install.packages("regpro")
library("regpro")
library(MASS)
#install.packages("forecast")
library("forecast")
# notes 2015-11-20
#1. ETL (cleaning, organizing section), factor in for missing data, outliers, etc.
# -> think of the opportunistic time intervals to trade (don't decide arbritarily, decide based on
# intelligence)
# -> separate the strategy from the market module in the flow chart
# -> market sends back fills and acknowledgements (assume we don't need this)
# -> strategy will act only upon "fill" (may not need to do this) and "timer"
# -> market reacts to order,replace,cancel and market data
# -> change active and passive to fill and timer
# -> highlight strategy with more detail
#knitr::spin
>>>>>>> origin/master
init_cash = 100000
#global_variables: position matrices, trade matrices, ourdata, order book
#order format: msgtype, symbol, price, quantity, side, ordtype, orderID, time
#execution message format: orderID, Execstatus, symbol, quantity, avg price, side, time
#Execstatus can be the following: filled, replaced, cancelled, replacereject?, cancelreject
#order book format: orderID, time, symbol, price, quantity, side, ordtype
#trade matrix format: time, symbol, side, quantity, price, open/close, pnl
#position matrix: time, asset, #of shares, book value, market value,
datafile_name = "../data/TSXdatafile.xls"
global_tables = new.env()
global_tables[[Con_GlobalVarName_LOB]]<- data.frame(matrix(0, 0, length(orderbook_spec)))
colnames(global_tables[[Con_GlobalVarName_LOB]]) <- orderbook_spec
#the position book is a list of data frames
init_pos <- data.frame(matrix(0, 1, length(positionbook_spec)))
colnames(init_pos) <- positionbook_spec
init_pos[,Con_FieldName_Sym] = Con_Sym_Cash
init_pos[,c(Con_FieldName_Qty, Con_FieldName_BookVal, Con_FieldName_MktVal)] = init_cash
global_tables[[Con_GlobalVarName_PositionBook]] <- list(init_pos)
names(global_tables[[Con_GlobalVarName_PositionBook]])[1] = 0
global_tables[[Con_GlobalVarName_TradesBook]] <- data.frame(matrix(0, 0, length(tradesbook_spec)))
colnames(global_tables[[Con_GlobalVarName_TradesBook]]) <- tradesbook_spec
global_tables[[Con_GlobalVarName_ListDates]] <- list(vector())
import_data(global_tables)
<<<<<<< HEAD
var <- read.csv("CPD_ask.csv")
View(var)
head(var)
debugSource('E:/YEAR 4/Code/APS490RBCCM/data_cleaning.R')
import_data(global_tables)
testy
head(testy)
na-rows
na_rows
head(testy)
debugSource('E:/YEAR 4/Code/APS490RBCCM/data_cleaning.R')
import_data(global_tables)
head(testy)
head(testy)
head(env[[nm]])
list_times_vec
head(list_times_vec)
head(env[[nm]])
nm
import_data(global_tables)
debugSource('E:/YEAR 4/Code/APS490RBCCM/data_cleaning.R')
import_data(global_tables)
head(testy)
testy[rw-1,1:4]
env[[nm]][1,1:4]
env[[nm]][1,2:5]
head(testy)
list_times_vec
head(testy)
head(env[[nm]])
head(testy)
source('E:/YEAR 4/Code/APS490RBCCM/data_cleaning.R')
import_data(global_tables)
debugSource('E:/YEAR 4/Code/APS490RBCCM/data_cleaning.R')
import_data(global_tables)
strftime(env[[nm]][rw,"Date"]
)
strftime(env[[nm]][rw,"Date"], format="%H:%M:%S")
strftime(env[[nm]][rw,"Date"], format="%H:%M:%S")
debugSource('E:/YEAR 4/Code/APS490RBCCM/data_cleaning.R')
import_data(global_tables)
head(testy)
import_data(global_tables)
strategy_impliedpricerisk(c("CPD", "SU", "ABX"), global_tables, 1950, 1950, 1950)
results <- data.frame()
for (i in 1:length(global_tables$positionbook)){
results <- rbind(results, portfoliovalue = sum(global_tables$positionbook[[i]]["MarketValue"]))
}
results
global_tables$tradesbook
=======
# output <- output(global_tables$tradesbook, global_tables$positionbook, global_tables$ask_price,
#                   global_tables$bid_price, globa_tables$market_data)
system.time({predic_accuracy <- test_HMMM(global_tables, 'BMO', 5, 3)})
result<-sum(comparison[!is.na(comparison)]) / (nrow(comparison) * ncol(comparison))
result
predic_accuracy
global_tables$positionbook
global_tables$tradesbook
predic_accuracy
source('strategy_hmm.r')
<<<<<<< Updated upstream
library(XLConnect)
#library(knitr)
#install.packages("regpro")
library("regpro")
init_cash = 100000
#global_variables: position matrices, trade matrices, ourdata, order book
#order format: msgtype, symbol, price, quantity, side, ordtype, orderID, time
#execution message format: orderID, Execstatus, symbol, quantity, avg price, side, time
#Execstatus can be the following: filled, replaced, cancelled, replacereject?, cancelreject
#order book format: orderID, time, symbol, price, quantity, side, ordtype
#trade matrix format: time, symbol, side, quantity, price, open/close, pnl
#position matrix: time, asset, #of shares, book value, market value,
datafile_name = "../data/TSXdatafile.xls"
global_tables = new.env()
global_tables[[Con_GlobalVarName_LOB]]<- data.frame(matrix(0, 0, length(orderbook_spec)))
colnames(global_tables[[Con_GlobalVarName_LOB]]) <- orderbook_spec
#the position book is a list of data frames
init_pos <- data.frame(matrix(0, 1, length(positionbook_spec)))
colnames(init_pos) <- positionbook_spec
init_pos[,Con_FieldName_Sym] = Con_Sym_Cash
init_pos[,c(Con_FieldName_Qty, Con_FieldName_BookVal, Con_FieldName_MktVal)] = init_cash
global_tables[[Con_GlobalVarName_PositionBook]] <- list(init_pos)
names(global_tables[[Con_GlobalVarName_PositionBook]])[1] = 0
global_tables[[Con_GlobalVarName_TradesBook]] <- data.frame(matrix(0, 0, length(tradesbook_spec)))
colnames(global_tables[[Con_GlobalVarName_TradesBook]]) <- tradesbook_spec
global_tables[[Con_GlobalVarName_ListDates]] <- list(vector())
import_data(global_tables)
# output <- output(global_tables$tradesbook, global_tables$positionbook, global_tables$ask_price,
#                   global_tables$bid_price, globa_tables$market_data)
system.time({predic_accuracy <- test_HMMM(global_tables, 'BNS', 5, 3)})
VWAP[,2:(Tnum + 1)] - VWAP[,1:Tnum]
p_increments
>>>>>>> origin/master
=======
system.time({predic_accuracy <- test_HMMM(global_tables, 'BMO', 5, 3)})
comparison
predic_accuracy
global_tables$positionbook
global_tables$tradesbook
predic_accuracy
system.time({predic_accuracy <- test_HMMM(global_tables, 'BMO', 10, 3)})
predic_accuracy
global_tables$positionbook
global_tables$tradesbook
global_tables$tradesbook[,6]
global_tables$tradesbook[6,]
global_tables$tradesbook
global_tables$tradesbook[,7]
plot(global_tables$tradesbook[,7])
plot(global_tables$tradesbook[,7],type="o", col="blue")
lines(global_tables$tradesbook[,7],type="o", col="blue")
lines(global_tables$tradesbook[,7])
plot(global_tables$tradesbook[,7],type="o", col="blue")
plot(global_tables$tradesbook[,7],type="b", col="blue")
plot(global_tables$tradesbook[,7])
>>>>>>> Stashed changes
>>>>>>> origin/master
